// ========================================
// GolfFox Create Route Page v11.0
// Pagina de criacao e edicao de rotas
// ========================================

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';

import '../../core/i18n/i18n.dart';
import '../../core/services/snackbar_service.dart';
import '../../core/theme/gf_tokens.dart';
import '../../models/route.dart';
import '../../services/route_service.dart';
import '../../ui/widgets/gf_app_bar.dart';
import '../../ui/widgets/routes/route_stop_item.dart';

class CreateRoutePage extends ConsumerStatefulWidget {
  const CreateRoutePage({
    super.key,
    this.route,
    this.isAutoGenerated = false,
  });
  final BusRoute? route;
  final bool isAutoGenerated;

  @override
  ConsumerState<CreateRoutePage> createState() => _CreateRoutePageState();
}

class _CreateRoutePageState extends ConsumerState<CreateRoutePage> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();

  String? _selectedVehicle;
  String? _selectedDriver;
  TimeOfDay? _scheduledStartTime;
  List<RouteStop> _stops = [];
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _initializeForm();
  }

  void _initializeForm() {
    if (widget.route != null) {
      _nameController.text = widget.route!.name;
      _descriptionController.text = widget.route!.description ?? '';
      _selectedVehicle = widget.route!.vehicleId;
      _selectedDriver = widget.route!.driverId;
      _scheduledStartTime = widget.route!.scheduledStartTime != null
          ? TimeOfDay.fromDateTime(widget.route!.scheduledStartTime!)
          : null;
      _stops = List.from(widget.route!.stops);
    } else if (widget.isAutoGenerated) {
      _generateAutomaticRoute();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => Scaffold(
        appBar: GfAppBar(
          title: widget.route != null
              ? I18n.t(context, 'routes.edit.title')
              : I18n.t(context, 'routes.action.new'),
          actions: [
            if (!widget.isAutoGenerated)
              IconButton(
                onPressed: _generateAutomaticRoute,
                icon: const Icon(Icons.auto_awesome),
                tooltip: I18n.t(context, 'routes.generate.auto'),
              ),
          ],
        ),
        body: Form(
          key: _formKey,
          child: Column(
            children: [
              Expanded(
                child: SingleChildScrollView(
                  padding: const EdgeInsets.all(GfTokens.space4),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Informacoes basicas
                      _buildBasicInfoSection(),

                      const SizedBox(height: GfTokens.space6),

                      // Atribuicoes
                      _buildAssignmentSection(),

                      const SizedBox(height: GfTokens.space6),

                      // Paradas
                      _buildStopsSection(),
                    ],
                  ),
                ),
              ),

              // Botoes de acao
              _buildActionButtons(),
            ],
          ),
        ),
      );

  Widget _buildBasicInfoSection() => Card(
        child: Padding(
          padding: const EdgeInsets.all(GfTokens.space4),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Informacoes Basicas',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Color(GfTokens.colorOnSurface),
                ),
              ),
              const SizedBox(height: GfTokens.space4),

              // Nome da rota
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  labelText: 'Nome da Rota *',
                  hintText: 'Ex: Rota Centro - Universidade',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Nome da rota e obrigatorio';
                  }
                  return null;
                },
              ),

              const SizedBox(height: GfTokens.space3),

              // Descricao
              TextFormField(
                controller: _descriptionController,
                decoration: const InputDecoration(
                  labelText: 'Descricao',
                  hintText: 'Descricao opcional da rota',
                  border: OutlineInputBorder(),
                ),
                maxLines: 3,
              ),

              const SizedBox(height: GfTokens.space3),

              // Horario programado
              InkWell(
                onTap: _selectScheduledTime,
                child: InputDecorator(
                  decoration: const InputDecoration(
                    labelText: 'Horario de Inicio',
                    border: OutlineInputBorder(),
                    suffixIcon: Icon(Icons.access_time),
                  ),
                  child: Text(
                    _scheduledStartTime != null
                        ? _scheduledStartTime!.format(context)
                        : 'Selecionar horario',
                    style: TextStyle(
                      color: _scheduledStartTime != null
                          ? const Color(GfTokens.colorOnSurface)
                          : const Color(GfTokens.colorOnSurfaceVariant),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      );

  Widget _buildAssignmentSection() => Card(
        child: Padding(
          padding: const EdgeInsets.all(GfTokens.space4),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Atribuicoes',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Color(GfTokens.colorOnSurface),
                ),
              ),
              const SizedBox(height: GfTokens.space4),

              // Veiculo
              DropdownButtonFormField<String>(
                initialValue: _selectedVehicle,
                decoration: const InputDecoration(
                  labelText: 'Veiculo',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.directions_bus),
                ),
                items: _getVehicleOptions()
                    .map(
                      (vehicle) => DropdownMenuItem(
                        value: vehicle,
                        child: Text('Veiculo $vehicle'),
                      ),
                    )
                    .toList(),
                onChanged: (value) => setState(() => _selectedVehicle = value),
              ),

              const SizedBox(height: GfTokens.space3),

              // Motorista
              DropdownButtonFormField<String>(
                initialValue: _selectedDriver,
                decoration: const InputDecoration(
                  labelText: 'Motorista',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.person),
                ),
                items: _getDriverOptions()
                    .map(
                      (driver) => DropdownMenuItem(
                        value: driver,
                        child: Text(driver),
                      ),
                    )
                    .toList(),
                onChanged: (value) => setState(() => _selectedDriver = value),
              ),
            ],
          ),
        ),
      );

  Widget _buildStopsSection() => Card(
        child: Padding(
          padding: const EdgeInsets.all(GfTokens.space4),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  const Text(
                    'Paradas da Rota',
                    style: TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: Color(GfTokens.colorOnSurface),
                    ),
                  ),
                  const Spacer(),
                  if (!widget.isAutoGenerated) ...[
                    IconButton(
                      onPressed: _addStop,
                      icon: const Icon(Icons.add),
                      tooltip: 'Adicionar Parada',
                    ),
                    IconButton(
                      onPressed: _generateAutomaticRoute,
                      icon: const Icon(Icons.auto_awesome),
                      tooltip: 'Gerar Automaticamente',
                    ),
                  ],
                ],
              ),
              if (_stops.isEmpty) ...[
                const SizedBox(height: GfTokens.space4),
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.all(GfTokens.space6),
                  decoration: BoxDecoration(
                    color: const Color(GfTokens.surface),
                    borderRadius: BorderRadius.circular(GfTokens.radiusMd),
                    border: Border.all(color: const Color(GfTokens.stroke)),
                  ),
                  child: Column(
                    children: [
                      const Icon(
                        Icons.location_on,
                        size: 48,
                        color: Color(GfTokens.colorOnSurfaceVariant),
                      ),
                      const SizedBox(height: GfTokens.space2),
                      const Text(
                        'Nenhuma parada adicionada',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.w500,
                          color: Color(GfTokens.colorOnSurfaceVariant),
                        ),
                      ),
                      const SizedBox(height: GfTokens.space2),
                      const Text(
                        'Adicione paradas manualmente ou gere uma rota automaticamente',
                        style: TextStyle(
                          fontSize: 14,
                          color: Color(GfTokens.colorOnSurfaceVariant),
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: GfTokens.space4),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          ElevatedButton.icon(
                            onPressed: _addStop,
                            icon: const Icon(Icons.add),
                            label: const Text('Adicionar Parada'),
                          ),
                          const SizedBox(width: GfTokens.space2),
                          OutlinedButton.icon(
                            onPressed: _generateAutomaticRoute,
                            icon: const Icon(Icons.auto_awesome),
                            label: const Text('Gerar Automaticamente'),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ] else ...[
                const SizedBox(height: GfTokens.space4),
                ReorderableListView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: _stops.length,
                  onReorder: _reorderStops,
                  itemBuilder: (context, index) {
                    final stop = _stops[index];
                    return RouteStopItem(
                      key: ValueKey(stop.id),
                      stop: stop,
                      index: index,
                      onEdit: () => _editStop(index),
                      onDelete: () => _deleteStop(index),
                    );
                  },
                ),
              ],
            ],
          ),
        ),
      );

  Widget _buildActionButtons() => Container(
        padding: const EdgeInsets.all(GfTokens.space4),
        decoration: const BoxDecoration(
          color: Color(GfTokens.surface),
          border: Border(
            top: BorderSide(color: Color(GfTokens.stroke)),
          ),
        ),
        child: Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('Cancelar'),
              ),
            ),
            const SizedBox(width: GfTokens.space3),
            Expanded(
              flex: 2,
              child: ElevatedButton(
                onPressed: _isLoading ? null : _saveRoute,
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(GfTokens.primary),
                  foregroundColor: Colors.white,
                ),
                child: _isLoading
                    ? const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor:
                              AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      )
                    : Text(
                        widget.route != null ? 'Atualizar Rota' : 'Criar Rota'),
              ),
            ),
          ],
        ),
      );

  Future<void> _selectScheduledTime() async {
    final time = await showTimePicker(
      context: context,
      initialTime: _scheduledStartTime ?? TimeOfDay.now(),
    );

    if (time != null) {
      setState(() => _scheduledStartTime = time);
    }
  }

  void _addStop() {
    // Em uma implementacao real, isso abriria um mapa para selecionar a localizacao
    final newStop = RouteStop(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      name: 'Nova Parada ${_stops.length + 1}',
      position: const LatLng(-23.5505, -46.6333), // Sao Paulo como exemplo
      type: StopType.waypoint,
      order: _stops.length,
    );

    setState(() => _stops.add(newStop));
  }

  void _editStop(int index) {
    // Em uma implementacao real, isso abriria um dialogo para editar a parada
    showDialog<void>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Editar Parada'),
        content: const Text('Funcionalidade de edicao sera implementada'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _deleteStop(int index) {
    setState(() => _stops.removeAt(index));

    // Reordenar as paradas
    for (var i = 0; i < _stops.length; i++) {
      _stops[i] = _stops[i].copyWith(order: i);
    }
  }

  void _reorderStops(int oldIndex, int newIndex) {
    var targetIndex = newIndex;
    if (targetIndex > oldIndex) {
      targetIndex--;
    }

    setState(() {
      final stop = _stops.removeAt(oldIndex);
      _stops.insert(targetIndex, stop);

      // Atualizar a ordem das paradas
      for (var i = 0; i < _stops.length; i++) {
        _stops[i] = _stops[i].copyWith(order: i);
      }
    });
  }

  Future<void> _generateAutomaticRoute() async {
    setState(() => _isLoading = true);

    try {
      final routeService = ref.read(routeServiceProvider);
      final waypoints = [
        const LatLng(-23.5567, -46.6389),
        const LatLng(-23.5589, -46.6456),
        const LatLng(-23.5612, -46.6501),
        const LatLng(-23.5629, -46.6544),
      ];

      final generatedRoute = await routeService.generateAutoRoute(
        name: 'Rota AutomÃ¡tica ${DateTime.now().day}/${DateTime.now().month}',
        waypoints: waypoints,
        startTime: DateTime.now().add(const Duration(hours: 1)),
      );

      setState(() {
        _stops = generatedRoute.stops;
        if (_nameController.text.isEmpty) {
          _nameController.text = generatedRoute.name;
        }
        if (_descriptionController.text.isEmpty) {
          _descriptionController.text = generatedRoute.description ?? '';
        }
      });

      if (mounted) {
        SnackBarService.success(context, 'routes.generate.success');
      }
    } on Exception catch (e) {
      if (mounted) {
        SnackBarService.error(context, e);
      }
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _saveRoute() async {
    final formState = _formKey.currentState;
    if (formState == null || !formState.validate()) return;
    if (_stops.isEmpty) {
      SnackBarService.warn(context, 'routes.stops.required');
      return;
    }

    setState(() => _isLoading = true);

    try {
      final routeService = ref.read(routeServiceProvider);

      final route = BusRoute(
        id: widget.route?.id ??
            DateTime.now().millisecondsSinceEpoch.toString(),
        name: _nameController.text.trim(),
        description: _descriptionController.text.trim().isEmpty
            ? null
            : _descriptionController.text.trim(),
        stops: _stops,
        vehicleId: _selectedVehicle,
        driverId: _selectedDriver,
        status: widget.route?.status ?? RouteStatus.planned,
        scheduledStartTime: _scheduledStartTime != null
            ? DateTime.now().copyWith(
                hour: _scheduledStartTime!.hour,
                minute: _scheduledStartTime!.minute,
              )
            : null,
        createdAt: widget.route?.createdAt ?? DateTime.now(),
        updatedAt: DateTime.now(),
      );

      if (widget.route != null) {
        await routeService.updateRoute(route);
      } else {
        await routeService.createRoute(route);
      }

      if (mounted) {
        Navigator.of(context).pop();
        SnackBarService.success(
          context,
          widget.route != null
              ? 'routes.update.success'
              : 'routes.create.success',
        );
      }
    } on Exception catch (e) {
      if (mounted) {
        SnackBarService.error(context, e);
      }
    } finally {
      setState(() => _isLoading = false);
    }
  }

  List<String> _getVehicleOptions() => ['001', '002', '003', '004', '005'];

  List<String> _getDriverOptions() => [
        'Joao Silva',
        'Maria Santos',
        'Pedro Oliveira',
        'Ana Costa',
        'Carlos Lima'
      ];
}
