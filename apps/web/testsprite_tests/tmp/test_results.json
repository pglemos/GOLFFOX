[
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "597db3d8-4b89-4a9b-8f32-bcf178d1d3ca",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC001-user login endpoint validation",
    "description": "Test the /api/auth/login POST endpoint for successful login with valid credentials, handling of invalid credentials, missing data, authentication failure, and CSRF validation failure.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/auth/login\"\nTIMEOUT = 30\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\n\ndef test_user_login_endpoint_validation():\n    headers = {\n        \"Content-Type\": \"application/json\",\n        # Basic token authentication: using HTTP Basic Auth header with provided credentials\n        # Encoding username:password in base64 is normally done by requests when using auth parameter\n    }\n\n    # 1. Successful login with valid credentials\n    try:\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json={\"email\": AUTH_USERNAME, \"password\": AUTH_PASSWORD},\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 200, f\"Expected 200 on valid login, got {response.status_code}\"\n        json_data = response.json()\n        assert \"token\" in json_data, \"Response JSON must contain token\"\n        assert \"refreshToken\" in json_data, \"Response JSON must contain refreshToken\"\n        assert \"user\" in json_data and isinstance(json_data[\"user\"], dict), \"User object required\"\n        assert \"session\" in json_data and isinstance(json_data[\"session\"], dict), \"Session object required\"\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Failed valid login test: {e}\")\n\n    # 2. Invalid credentials - wrong password\n    try:\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json={\"email\": AUTH_USERNAME, \"password\": \"wrongpassword\"},\n            timeout=TIMEOUT,\n        )\n        assert response.status_code in (400, 401), f\"Expected 400 or 401 for invalid credentials, got {response.status_code}\"\n    except requests.RequestException as e:\n        raise AssertionError(f\"Request failed for invalid credentials: {e}\")\n\n    # 3. Missing data - missing password\n    try:\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json={\"email\": AUTH_USERNAME},\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 400, f\"Expected 400 for missing password, got {response.status_code}\"\n    except requests.RequestException as e:\n        raise AssertionError(f\"Request failed for missing password: {e}\")\n\n    # 4. Missing data - missing email\n    try:\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json={\"password\": AUTH_PASSWORD},\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 400, f\"Expected 400 for missing email, got {response.status_code}\"\n    except requests.RequestException as e:\n        raise AssertionError(f\"Request failed for missing email: {e}\")\n\n    # 5. Empty JSON payload (missing both email and password)\n    try:\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json={},\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 400, f\"Expected 400 for empty payload, got {response.status_code}\"\n    except requests.RequestException as e:\n        raise AssertionError(f\"Request failed for empty payload: {e}\")\n\n    # 6. Authentication failure scenario - simulate by invalid email format\n    try:\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json={\"email\": \"invalid_email_format\", \"password\": AUTH_PASSWORD},\n            timeout=TIMEOUT,\n        )\n        # Could be 400 for validation error or 401 for authentication failed or 422 for validation error\n        assert response.status_code in (400, 401, 422), f\"Expected 400, 401 or 422 for invalid email format, got {response.status_code}\"\n    except requests.RequestException as e:\n        raise AssertionError(f\"Request failed for invalid email format: {e}\")\n\n    # 7. CSRF validation failure - Since CSRF token required for mutating calls,\n    # simulate by sending header or cookie invalid or missing\n    # But API doc does not specify how CSRF token is passed on login endpoint\n    # Usually login might be exempt or accept a CSRF header\n    # We'll try sending an invalid CSRF header to elicit 403 response\n\n    # Attempt with invalid CSRF token header\n    try:\n        headers_with_csrf = {\"Content-Type\": \"application/json\", \"x-csrf-token\": \"invalid-token\"}\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json={\"email\": AUTH_USERNAME, \"password\": AUTH_PASSWORD},\n            headers=headers_with_csrf,\n            timeout=TIMEOUT,\n        )\n        if response.status_code == 403:\n            # Expected CSRF validation failure\n            pass\n        else:\n            # 403 not returned, maybe CSRF not enforced on login, so just verify code is not 200 error\n            assert response.status_code != 200, \"Expected non-200 response when CSRF token invalid\"\n    except requests.RequestException as e:\n        raise AssertionError(f\"Request failed for CSRF validation failure test: {e}\")\n\ntest_user_login_endpoint_validation()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.141Z",
    "modified": "2025-11-25T04:12:17.874Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "20f2f007-1b29-4985-82c5-3b6d4199e849",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC002-vehicle deletion or archival with trip validation",
    "description": "Test the /api/admin/vehicles/{vehicleId} DELETE endpoint to verify vehicle deletion or archival behavior when the vehicle has associated trips, including validation of vehicle ID and handling of conflicts.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nVEHICLE_URL_TEMPLATE = f\"{BASE_URL}/api/admin/vehicles/{{vehicle_id}}\"\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\nTIMEOUT = 30\n\n\ndef test_vehicle_deletion_or_archival_with_trip_validation():\n    session = requests.Session()\n\n    # Step 1: Login to get authentication token (basic token)\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    try:\n        login_resp = session.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token and isinstance(token, str), \"No token found in login response\"\n    except Exception as e:\n        raise AssertionError(f\"Login request failed: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Helper function to create a vehicle (simulate creation for test) to get a vehicleId\n    # Because the PRD does not have vehicle creation doc, assume there is a post endpoint at /api/admin/vehicles\n    # We will try to create a minimal vehicle for test purposes and then delete it after test\n    # Vehicle creation schema is unknown so we will create a dummy vehicle with a unique plate number or name.\n    new_vehicle_id = None\n    try:\n        create_vehicle_url = f\"{BASE_URL}/api/admin/vehicles\"\n        vehicle_payload = {\n            \"plate\": f\"TEST-{uuid.uuid4().hex[:8]}\",\n            \"model\": \"Test Model\",\n            \"brand\": \"Test Brand\",\n            \"year\": 2020,\n            \"capacity\": 40\n        }\n        create_resp = session.post(create_vehicle_url, json=vehicle_payload, headers=headers, timeout=TIMEOUT)\n        assert create_resp.status_code in (200, 201), f\"Vehicle creation failed with status {create_resp.status_code}\"\n        vehicle_data = create_resp.json()\n        new_vehicle_id = vehicle_data.get(\"id\")\n        assert new_vehicle_id, \"Created vehicle ID not returned\"\n\n        # Step 2: Attempt to delete vehicle with invalid vehicleId (should return 400)\n        invalid_vehicle_id = \"invalid-uuid\"\n        del_invalid_resp = session.delete(VEHICLE_URL_TEMPLATE.format(vehicle_id=invalid_vehicle_id),\n                                          headers=headers, timeout=TIMEOUT)\n        assert del_invalid_resp.status_code == 400, f\"Expected 400 on invalid vehicle ID, got {del_invalid_resp.status_code}\"\n\n        # Step 3: Delete the newly created vehicle (should succeed with 200 or archive if trips exist)\n        del_resp = session.delete(VEHICLE_URL_TEMPLATE.format(vehicle_id=new_vehicle_id),\n                                  headers=headers, timeout=TIMEOUT)\n        assert del_resp.status_code == 200, f\"Vehicle delete failed with status {del_resp.status_code}\"\n\n        del_json = del_resp.json()\n        assert isinstance(del_json, dict), \"Response is not a JSON object\"\n        assert \"success\" in del_json, \"'success' key missing in response\"\n        assert isinstance(del_json[\"success\"], bool), \"'success' value not boolean\"\n        # archived may be true if vehicle has trips linked; can be false if vehicle deleted completely\n        assert \"archived\" in del_json, \"'archived' key missing in response\"\n        assert isinstance(del_json[\"archived\"], bool), \"'archived' value not boolean\"\n        # tripsCount indicates how many trips linked to vehicle\n        assert \"tripsCount\" in del_json, \"'tripsCount' key missing in response\"\n        assert isinstance(del_json[\"tripsCount\"], int), \"'tripsCount' value not integer\"\n        # If trips exist, vehicle shouldn't be fully deleted but archived (archived=True)\n        if del_json[\"tripsCount\"] > 0:\n            assert del_json[\"archived\"] is True, \"Vehicle with trips must be archived, not deleted\"\n        else:\n            # If no trips, archived may be false as vehicle deleted completely\n            assert del_json[\"success\"] is True, \"Success should be True on successful deletion\"\n\n        # Step 4: Try delete a vehicle that is in use but simulate conflict by deleting twice\n        # Attempting to delete again should return 409 if vehicle in use or does not exist\n        del_again_resp = session.delete(VEHICLE_URL_TEMPLATE.format(vehicle_id=new_vehicle_id),\n                                        headers=headers, timeout=TIMEOUT)\n\n        # Expected 409 conflict or possibly 400 or 404 depending on implementation, we expect 409 on conflict per doc\n        assert del_again_resp.status_code in (409, 400, 404), \\\n            f\"Expected 409, 400 or 404 on deleting the same vehicle again, got {del_again_resp.status_code}\"\n\n    finally:\n        # Cleanup: If vehicle still exists, try to delete without assertions to avoid test failure in cleanup\n        if new_vehicle_id:\n            try:\n                session.delete(VEHICLE_URL_TEMPLATE.format(vehicle_id=new_vehicle_id), headers=headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n\n\ntest_vehicle_deletion_or_archival_with_trip_validation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 102, in <module>\n  File \"<string>\", line 51, in test_vehicle_deletion_or_archival_with_trip_validation\nAssertionError: Vehicle creation failed with status 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.148Z",
    "modified": "2025-11-25T04:12:00.605Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "fd435455-e25f-492c-a66a-7fef0e029d93",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC003-generate optimized route stops",
    "description": "Test the /api/admin/generate-stops POST endpoint to ensure optimized route stops are generated successfully for a given route_id and handle failure scenarios.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nGENERATE_STOPS_URL = f\"{BASE_URL}/api/admin/generate-stops\"\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\ndef test_generate_optimized_route_stops():\n    timeout = 30\n\n    # Step 1: Authenticate and get token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    login_headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        login_response = requests.post(\n            LOGIN_URL,\n            json=login_payload,\n            headers=login_headers,\n            timeout=timeout\n        )\n        login_response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    login_data = login_response.json()\n    token = login_data.get(\"token\")\n    assert token, \"Login response missing token\"\n\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Helper function to create a dummy route to get a route_id\n    # No create route endpoint specified in PRD, so test with an invalid and valid scenario\n\n    # Since no route creation endpoint info, test with an invalid route_id first to validate failure\n    invalid_route_id_payload = {\"route_id\": \"00000000-0000-0000-0000-000000000000\"}\n    try:\n        response = requests.post(\n            GENERATE_STOPS_URL,\n            json=invalid_route_id_payload,\n            headers=headers,\n            timeout=timeout\n        )\n    except requests.RequestException as e:\n        assert False, f\"Request failed for invalid route_id: {e}\"\n\n    # According to PRD, only 200 (success) and 500 (failure) responses documented.\n    # For invalid route_id expect failure scenario with 500 or some error status.\n    assert response.status_code in (200, 500), f\"Unexpected status {response.status_code} for invalid route_id test\"\n    if response.status_code == 500:\n        # Failure scenario handled correctly\n        pass\n    else:\n        # Sometimes API could respond 200 if route_id exists, unexpected success - no failure handling\n        pass\n\n    # Now for success scenario:\n    # Since no info on how to create route or get existing route_id, try to discover a route_id by other means:\n    # For the test, the best we can do is create a route_id in a try-finally block if creation was possible.\n    # Here, no route creation endpoint described in PRD, so we can't dynamically create a route.\n    # Instead, we will skip dynamic creation and expect the test to be run with a known valid route_id.\n    # To follow instructions, we must do try-finally with a created resource if resource id not provided,\n    # but PRD/test plan do not provide or specify route creation. So, we will simulate with a placeholder route_id.\n\n    # Placeholder valid UUID format route_id (simulate success scenario)\n    valid_route_id = \"123e4567-e89b-12d3-a456-426614174000\"\n    valid_payload = {\"route_id\": valid_route_id}\n\n    try:\n        post_response = requests.post(\n            GENERATE_STOPS_URL,\n            json=valid_payload,\n            headers=headers,\n            timeout=timeout\n        )\n    except requests.RequestException as e:\n        assert False, f\"Request failed for valid route_id: {e}\"\n\n    # Assert success response 200 with message or empty body possible\n    assert post_response.status_code == 200, f\"Expected 200 status for valid route_id, got {post_response.status_code}\"\n\n    # The PRD does not define response body schema on success, just the description:\n    # \"Stops generated successfully\" for 200, so assume no required fields.\n    # If response json is present, just ensure it's parseable.\n    try:\n        post_response.json()\n    except Exception:\n        # If no json body returned that's also acceptable unless stated otherwise\n        pass\n\ntest_generate_optimized_route_stops()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.154Z",
    "modified": "2025-11-25T04:11:44.431Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "8795fab7-fcbc-46c2-b667-a145b9f697a0",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC004-create new operator user",
    "description": "Test the /api/admin/create-operator POST endpoint for creating a new operator user with valid email and company_id, including validation of input data and error handling.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nAPI_PATH = \"/api/admin/create-operator\"\nTIMEOUT = 30\nAUTH = (\"golffox@admin.com\", \"senha123\")\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_create_new_operator_user():\n    # Generate unique email to avoid conflicts\n    new_email = f\"operator_{uuid.uuid4()}@test.com\"\n    # For testing, we need a valid company_id UUID.\n    # Since PRD doesn't provide a direct endpoint to get companies, we use a UUID placeholder.\n    # In a real scenario, fetch a valid company_id from a pre-existing test fixture or a companies list endpoint.\n    sample_company_id = str(uuid.uuid4())\n\n    payload = {\n        \"email\": new_email,\n        \"company_id\": sample_company_id\n    }\n\n    # Successful creation\n    response = requests.post(\n        f\"{BASE_URL}{API_PATH}\",\n        auth=AUTH,\n        headers=HEADERS,\n        json=payload,\n        timeout=TIMEOUT\n    )\n    try:\n        assert response.status_code == 201, f\"Expected 201, got {response.status_code}\"\n        json_resp = response.json()\n        # Response content not explicitly defined beyond 201 description, so check minimal assumptions\n        # Usually a created resource response might contain the created user's info or ID\n        assert isinstance(json_resp, dict)\n        assert \"email\" not in json_resp or json_resp.get(\"email\") == new_email or True  # Optional check\n    except Exception as e:\n        raise AssertionError(f\"Success case failed: {e}\")\n\n    # Test invalid data: invalid email format\n    invalid_payload = {\n        \"email\": \"invalid-email-format\",\n        \"company_id\": sample_company_id\n    }\n    response_invalid_email = requests.post(\n        f\"{BASE_URL}{API_PATH}\",\n        auth=AUTH,\n        headers=HEADERS,\n        json=invalid_payload,\n        timeout=TIMEOUT\n    )\n    assert response_invalid_email.status_code == 400, f\"Expected 400 for invalid email, got {response_invalid_email.status_code}\"\n\n    # Test invalid data: missing company_id\n    missing_company_payload = {\n        \"email\": f\"missingcompany_{uuid.uuid4()}@test.com\"\n    }\n    response_missing_company = requests.post(\n        f\"{BASE_URL}{API_PATH}\",\n        auth=AUTH,\n        headers=HEADERS,\n        json=missing_company_payload,\n        timeout=TIMEOUT\n    )\n    # According to PRD \"company_id\" is required, expect 400 for missing required fields\n    assert response_missing_company.status_code == 400, f\"Expected 400 for missing company_id, got {response_missing_company.status_code}\"\n\n    # Test internal server error handling by sending a malformed company_id (wrong UUID format)\n    malformed_company_payload = {\n        \"email\": f\"malformedcompany_{uuid.uuid4()}@test.com\",\n        \"company_id\": \"not-a-uuid\"\n    }\n    response_malformed_company = requests.post(\n        f\"{BASE_URL}{API_PATH}\",\n        auth=AUTH,\n        headers=HEADERS,\n        json=malformed_company_payload,\n        timeout=TIMEOUT\n    )\n    # The response can be 400 or 500 depending on server, accept either but prefer 400\n    assert response_malformed_company.status_code in (400, 500), (\n        f\"Expected 400 or 500 for malformed company_id, got {response_malformed_company.status_code}\"\n    )\n\n\ntest_create_new_operator_user()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.160Z",
    "modified": "2025-11-25T04:11:53.873Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "2cfccae1-d3ba-4a22-b88a-2c2d89c9bcef",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC005-manual cost entry creation and retrieval",
    "description": "Test the /api/costs/manual POST endpoint for creating manual cost entries with valid data and the GET endpoint for retrieving costs with various filters, including validation and authorization.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_manual_cost_entry_creation_and_retrieval():\n    auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Helper function: create manual cost entry\n    def create_manual_cost_entry(company_id, cost_category_id, date, amount, notes=None, source=\"manual\"):\n        payload = {\n            \"company_id\": company_id,\n            \"cost_category_id\": cost_category_id,\n            \"date\": date,\n            \"amount\": amount,\n            \"source\": source\n        }\n        if notes is not None:\n            payload[\"notes\"] = notes\n\n        response = requests.post(\n            f\"{BASE_URL}/api/costs/manual\",\n            auth=auth,\n            headers=headers,\n            json=payload,\n            timeout=TIMEOUT,\n        )\n        return response\n\n    # Helper function: get costs with filters\n    def get_costs(filters):\n        response = requests.get(\n            f\"{BASE_URL}/api/costs/manual\",\n            auth=auth,\n            headers=headers,\n            params=filters,\n            timeout=TIMEOUT,\n        )\n        return response\n\n    # Assumptions for required uuid fields for test (normally these would come from setup or fixtures)\n    # Since resource IDs are not provided, these below are dummy IDs (we assume valid ones exist in system)\n    # In a real scenario, the test would create or fetch valid company and cost category IDs before running tests.\n    test_company_id = str(uuid.uuid4())\n    test_cost_category_id = str(uuid.uuid4())\n\n    # Because we don't have a create company or category, the manual cost creation may fail.\n    # We'll run with these and later check if creation succeeds or fails accordingly.\n    # We try creating a manual cost entry\n    today = datetime.today().strftime(\"%Y-%m-%d\")\n    amount = 123.45\n    notes = \"Test cost entry notes\"\n\n    created_cost_id = None\n    try:\n        # 1. Test successful creation of manual cost entry\n        response = create_manual_cost_entry(test_company_id, test_cost_category_id, today, amount, notes)\n        assert response.status_code == 201, f\"Expected 201, got {response.status_code}, body: {response.text}\"\n        cost_created = response.json()\n        # The API schema doesn't specify returned body content on creation, so no id expected\n        # We assume success if status 201.\n\n        # 2. Test retrieval with only required filter company_id\n        filters = {\"company_id\": test_company_id}\n        response = get_costs(filters)\n        assert response.status_code == 200, f\"Expected 200, got {response.status_code}, body: {response.text}\"\n        costs_list = response.json()\n        assert isinstance(costs_list, (list, dict)), \"Expected list or dict in response\"\n        # If dict, we expect data inside, handle both cases\n        if isinstance(costs_list, dict):\n            # Possibly response is an object with costs array\n            # Check if costs exists\n            assert \"costs\" in costs_list or \"data\" in costs_list or True\n        # We optionally check that the created cost is among returned costs if data structure known\n\n        # 3. Test retrieval with filters: date range and category_id\n        filters = {\n            \"company_id\": test_company_id,\n            \"start_date\": today,\n            \"end_date\": today,\n            \"category_id\": test_cost_category_id,\n            \"limit\": 10,\n            \"offset\": 0\n        }\n        response = get_costs(filters)\n        assert response.status_code == 200, f\"Expected 200, got {response.status_code}, body: {response.text}\"\n        filtered_costs = response.json()\n        assert isinstance(filtered_costs, (list, dict)), \"Expected list or dict in response\"\n\n        # 4. Test retrieval missing required company_id returns 400\n        filters = {}\n        response = get_costs(filters)\n        assert response.status_code == 400, f\"Expected 400 when company_id missing, got {response.status_code}\"\n\n    finally:\n        # No delete endpoint specified for cost entries,\n        # unable to delete created manual cost entries.\n        # So no cleanup possible\n        pass\n\ntest_manual_cost_entry_creation_and_retrieval()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.167Z",
    "modified": "2025-11-25T04:11:49.566Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "af5cc711-c5b7-49ba-a231-e9fcea14ed3e",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC006-create employee as operator",
    "description": "Test the /api/operator/create-employee POST endpoint for creating an employee with valid data, handling existing employees, invalid data, unauthorized access, and server errors.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nCREATE_EMPLOYEE_ENDPOINT = \"/api/operator/create-employee\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\ndef test_create_employee_as_operator():\n    session = requests.Session()\n\n    # Step 1: Login to get Bearer Token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    login_headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        login_resp = session.post(\n            BASE_URL + LOGIN_ENDPOINT,\n            json=login_payload,\n            headers=login_headers,\n            timeout=TIMEOUT,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token, \"No token received after login\"\n    except requests.RequestException as e:\n        assert False, f\"Login request exception: {e}\"\n\n    auth_headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Test data for employee creation\n    # We'll do multiple tests: valid creation, existing employee, invalid data, unauthorized access\n\n    # 1. Valid creation test (create a unique employee)\n    import uuid\n    unique_email = f\"test_employee_{uuid.uuid4().hex}@example.com\"\n    employee_payload = {\n        \"email\": unique_email,\n        \"name\": \"Test Employee\",\n        \"phone\": \"+5511999999999\",\n        \"role\": \"passenger\"\n    }\n\n    created_user_id = None\n    try:\n        resp = session.post(\n            BASE_URL + CREATE_EMPLOYEE_ENDPOINT,\n            json=employee_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        # Either 201 created or 200 exists, both acceptable here\n        assert resp.status_code in (200, 201), f\"Unexpected status code: {resp.status_code} - {resp.text}\"\n        data = resp.json() if resp.content else {}\n        # Validate response content fields on create\n        if resp.status_code == 201:\n            # New employee created\n            created_user_id = data.get(\"userId\")\n            assert created_user_id, \"userId missing in creation response\"\n            assert data.get(\"created\") is True, \"created flag not True for new employee\"\n            assert data.get(\"email\") == unique_email\n            assert data.get(\"role\") == \"passenger\"\n            assert \"companyId\" in data and data[\"companyId\"], \"Missing companyId\"\n        elif resp.status_code == 200:\n            # Employee already exists\n            # Check mandatory keys to satisfy contract\n            assert \"email\" in data and data[\"email\"] == unique_email\n        else:\n            assert False, \"Unexpected status code for employee creation\"\n    except requests.RequestException as e:\n        assert False, f\"Request exception during valid employee creation: {e}\"\n\n    # 2. Duplicate creation - should return 200 (employee exists)\n    try:\n        resp_dup = session.post(\n            BASE_URL + CREATE_EMPLOYEE_ENDPOINT,\n            json=employee_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_dup.status_code == 200, f\"Expected 200 for existing employee, got {resp_dup.status_code} - {resp_dup.text}\"\n    except requests.RequestException as e:\n        assert False, f\"Request exception during duplicate employee creation: {e}\"\n\n    # 3. Invalid data test - missing required email field\n    invalid_payload = {\n        \"name\": \"No Email Employee\",\n        \"phone\": \"+5511988888888\",\n        \"role\": \"passenger\"\n    }\n    try:\n        resp_invalid = session.post(\n            BASE_URL + CREATE_EMPLOYEE_ENDPOINT,\n            json=invalid_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        # Should respond with 400 for invalid data\n        assert resp_invalid.status_code == 400, f\"Expected 400 for invalid data, got {resp_invalid.status_code} - {resp_invalid.text}\"\n    except requests.RequestException as e:\n        assert False, f\"Request exception during invalid employee creation: {e}\"\n\n    # 4. Unauthorized access test: no or invalid token\n    try:\n        resp_unauth = requests.post(\n            BASE_URL + CREATE_EMPLOYEE_ENDPOINT,\n            json=employee_payload,\n            headers={\"Content-Type\": \"application/json\"},  # No auth header\n            timeout=TIMEOUT,\n        )\n        assert resp_unauth.status_code == 401, f\"Expected 401 Unauthorized without token, got {resp_unauth.status_code} - {resp_unauth.text}\"\n    except requests.RequestException as e:\n        assert False, f\"Request exception during unauthorized employee creation: {e}\"\n\n    # Cleanup: delete created employee if possible (no delete endpoint info, so skipping cleanup)\n    # As PRD doesn't mention delete employee endpoint, leave created entity.\n\ntest_create_employee_as_operator()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.174Z",
    "modified": "2025-11-25T04:12:00.603Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "28524e93-e048-4e02-8a88-29592a1c3746",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC007-optimize route for operator",
    "description": "Test the /api/operator/optimize-route POST endpoint to verify successful route optimization for operators.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\n\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\n\nTIMEOUT = 30\n\ndef test_optimize_route_for_operator():\n    session = requests.Session()\n    # Authenticate to get Bearer token\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\n        \"email\": AUTH_USERNAME,\n        \"password\": AUTH_PASSWORD\n    }\n    try:\n        login_resp = session.post(login_url, json=login_payload, timeout=TIMEOUT)\n        login_resp.raise_for_status()\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        if not token:\n            assert False, \"Authentication token not found in login response.\"\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    optimize_url = f\"{BASE_URL}/api/operator/optimize-route\"\n    try:\n        resp = session.post(optimize_url, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        assert resp.status_code == 200\n        # Optionally verify response content if any\n    except requests.HTTPError as http_err:\n        assert False, f\"HTTP error during optimize route: {http_err} - Response: {resp.text}\"\n    except requests.RequestException as req_err:\n        assert False, f\"Request exception during optimize route: {req_err}\"\n\ntest_optimize_route_for_operator()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.180Z",
    "modified": "2025-11-25T04:12:03.727Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "6232e96c-8fb4-4938-a62b-9bd7a8671a01",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC008-generate report on demand",
    "description": "Test the /api/reports/run POST endpoint for generating reports on demand in various formats (pdf, excel, csv) with valid report_type and company_id.",
    "code": "import requests\n\ndef test_generate_report_on_demand():\n    base_url = \"http://localhost:3000\"\n    url = f\"{base_url}/api/reports/run\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    # Example valid report types and a dummy company_id for testing\n    report_types = [\"daily-summary\", \"fleet-performance\", \"cost-analysis\"]\n    formats = [\"pdf\", \"excel\", \"csv\"]\n    company_id = \"00000000-0000-0000-0000-000000000001\"\n\n    for report_type in report_types:\n        for fmt in formats:\n            payload = {\n                \"report_type\": report_type,\n                \"company_id\": company_id,\n                \"format\": fmt\n            }\n            try:\n                response = requests.post(url, json=payload, headers=headers, timeout=30)\n            except requests.RequestException as e:\n                assert False, f\"Request failed: {e}\"\n            assert response.status_code == 200, f\"Expected HTTP 200, got {response.status_code} for report_type: {report_type}, format: {fmt}\"\n            # For a report generated response, content-type might be application/pdf, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, or text/csv\n            content_type = response.headers.get(\"Content-Type\", \"\")\n            if fmt == \"pdf\":\n                assert \"pdf\" in content_type.lower(), f\"Expected PDF content type for format pdf, got {content_type}\"\n            elif fmt == \"excel\":\n                # Check for Excel MIME types\n                assert (\"spreadsheetml\" in content_type.lower() or \"excel\" in content_type.lower()), f\"Expected Excel content type for format excel, got {content_type}\"\n            elif fmt == \"csv\":\n                assert \"csv\" in content_type.lower() or \"text/plain\" in content_type.lower(), f\"Expected CSV content type for format csv, got {content_type}\"\n            # Assert some content is returned\n            assert response.content is not None and len(response.content) > 0, f\"Empty content for report_type: {report_type}, format: {fmt}\"\n\n\ntest_generate_report_on_demand()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 25, in test_generate_report_on_demand\nAssertionError: Expected HTTP 200, got 400 for report_type: daily-summary, format: pdf\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.187Z",
    "modified": "2025-11-25T04:12:28.111Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "76d40cc3-b349-4177-998c-e4da838ba36a",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC009-cron job to dispatch scheduled reports",
    "description": "Test the /api/cron/dispatch-reports POST endpoint to verify that scheduled reports are dispatched successfully and handle invalid CRON_SECRET authentication.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nCRON_DISPATCH_ENDPOINT = \"/api/cron/dispatch-reports\"\nTIMEOUT = 30\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\n\ndef test_cron_dispatch_reports():\n    # First, we do not know the valid CRON_SECRET, but the endpoint requires a header \"cron-secret\"\n    # We will test two cases:\n    # 1. Successful dispatch with a correct CRON_SECRET (simulate here with a placeholder \"VALID_SECRET\")\n    # 2. Failure dispatch with an invalid CRON_SECRET\n\n    session = requests.Session()\n    session.auth = HTTPBasicAuth(USERNAME, PASSWORD)\n\n    # Define headers and payload for valid and invalid cases\n    valid_headers = {\n        \"cron-secret\": \"VALID_SECRET\"\n    }\n    invalid_headers = {\n        \"cron-secret\": \"INVALID_SECRET\"\n    }\n\n    # Test case 1: Valid CRON_SECRET - Expect 200 with success message\n    try:\n        response = session.post(\n            BASE_URL + CRON_DISPATCH_ENDPOINT,\n            headers=valid_headers,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected 200, got {response.status_code}\"\n        # It's undefined what the response body content looks like on success,\n        # but likely a message or success field\n        try:\n            json_resp = response.json()\n            # If available, check presence of success indication\n            if isinstance(json_resp, dict):\n                assert (\n                    \"message\" in json_resp or \"success\" in json_resp or \"reports_dispatched\" in json_resp\n                ) or len(json_resp) == 0  # Accept empty json as well\n        except Exception:\n            # Accept if no JSON response\n            pass\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Test case 2: Invalid CRON_SECRET - Expect 401 Unauthorized\n    try:\n        response = session.post(\n            BASE_URL + CRON_DISPATCH_ENDPOINT,\n            headers=invalid_headers,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 401, f\"Expected 401 for invalid CRON_SECRET, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n\ntest_cron_dispatch_reports()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.193Z",
    "modified": "2025-11-25T04:12:11.009Z"
  },
  {
    "projectId": "8ee6cd08-1807-49c4-94dd-acd0e05a68f3",
    "testId": "c9dca542-72a5-498d-809f-0f5607e96f16",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC010-system health check endpoint",
    "description": "Test the /api/health GET endpoint to ensure it returns timely and accurate system health status with correct response structure.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime\n\ndef test_system_health_check_endpoint():\n    base_url = \"http://localhost:3000\"\n    endpoint = f\"{base_url}/api/health\"\n    auth = HTTPBasicAuth(\"golffox@admin.com\", \"senha123\")\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    timeout = 30\n\n    try:\n        response = requests.get(endpoint, headers=headers, auth=auth, timeout=timeout)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {endpoint} failed: {e}\"\n\n    # Validate response status code\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate response keys and types\n    assert \"status\" in data, \"Response JSON missing 'status' key\"\n    assert \"timestamp\" in data, \"Response JSON missing 'timestamp' key\"\n\n    assert isinstance(data[\"status\"], str), \"'status' should be a string\"\n    assert data[\"status\"].lower() == \"ok\", f\"Expected status 'ok', got '{data['status']}'\"\n\n    # Validate timestamp format (ISO 8601 / RFC 3339)\n    timestamp = data[\"timestamp\"]\n    assert isinstance(timestamp, str), \"'timestamp' should be a string\"\n    try:\n        # This will raise ValueError if the format is incorrect\n        datetime.fromisoformat(timestamp.replace(\"Z\",\"+00:00\"))\n    except ValueError:\n        assert False, f\"'timestamp' is not a valid ISO 8601 datetime string: {timestamp}\"\n\ntest_system_health_check_endpoint()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:11:07.200Z",
    "modified": "2025-11-25T04:12:19.414Z"
  }
]
