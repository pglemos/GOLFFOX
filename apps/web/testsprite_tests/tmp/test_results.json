[
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "1cec8cc0-4990-4035-827f-5d506a7b3641",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC001-user login endpoint validation",
    "description": "Test the /api/auth/login POST endpoint for successful login with valid credentials, handling of invalid credentials, missing data, authentication failure, and CSRF validation failure.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\n\ndef test_user_login_endpoint_validation():\n    url = BASE_URL + LOGIN_ENDPOINT\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # 1. Test successful login with valid credentials\n    valid_payload = {\n        \"email\": AUTH_USERNAME,\n        \"password\": AUTH_PASSWORD\n    }\n\n    try:\n        response = requests.post(url, json=valid_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 for valid login but got {response.status_code}\"\n        data = response.json()\n        assert \"token\" in data and isinstance(data[\"token\"], str) and len(data[\"token\"]) > 0, \"Missing or invalid token in response\"\n        assert \"refreshToken\" in data and isinstance(data[\"refreshToken\"], str) and len(data[\"refreshToken\"]) > 0, \"Missing or invalid refreshToken in response\"\n        assert \"user\" in data and isinstance(data[\"user\"], dict), \"Missing or invalid user object in response\"\n        assert \"session\" in data and isinstance(data[\"session\"], dict), \"Missing or invalid session object in response\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during valid login test: {e}\")\n\n    # 2. Test login with invalid credentials (wrong password)\n    invalid_payload = {\n        \"email\": AUTH_USERNAME,\n        \"password\": \"wrongpassword\"\n    }\n    try:\n        response = requests.post(url, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code in [400,401], f\"Expected 400 or 401 for invalid credentials but got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during invalid credentials test: {e}\")\n\n    # 3. Test login with missing email field\n    missing_email_payload = {\n        # \"email\": AUTH_USERNAME,  # omitted\n        \"password\": AUTH_PASSWORD\n    }\n    try:\n        response = requests.post(url, json=missing_email_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 400, f\"Expected 400 for missing email but got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during missing email test: {e}\")\n\n    # 4. Test login with missing password field\n    missing_password_payload = {\n        \"email\": AUTH_USERNAME\n        # \"password\": AUTH_PASSWORD  # omitted\n    }\n    try:\n        response = requests.post(url, json=missing_password_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 400, f\"Expected 400 for missing password but got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during missing password test: {e}\")\n\n    # 5. Test authentication failure (simulate by sending wrong credentials payload)\n    try:\n        response = requests.post(url, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code in [400,401], f\"Expected 400 or 401 for authentication failure but got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Exception during authentication failure test: {e}\")\n\n    # 6. Test CSRF validation failure\n    # As CSRF tokens are required for protected mutating API calls, simulate missing or invalid CSRF token header if required\n    # From PRD no explicit CSRF header mentioned for /api/auth/login, but instructions mention CSRF protection on protected mutating calls,\n    # Assuming this login endpoint requires a CSRF token header named \"X-CSRF-Token\" and sending invalid token should return 403\n    # We'll attempt to send invalid CSRF token to provoke a 403 response\n    headers_csrf_invalid = headers.copy()\n    headers_csrf_invalid[\"X-CSRF-Token\"] = \"invalid_csrf_token\"\n    try:\n        response = requests.post(url, json=valid_payload, headers=headers_csrf_invalid, timeout=TIMEOUT)\n        # The PRD states 403 on CSRF failures; if 200, then CSRF may not be enforced for login - just check if 403 possible\n        assert response.status_code in [200,403], f\"Expected 403 or 200 for CSRF test but got {response.status_code}\"\n        if response.status_code == 403:\n            # CSRF validation failure successfully tested\n            pass\n    except Exception as e:\n        raise AssertionError(f\"Exception during CSRF validation failure test: {e}\")\n\ntest_user_login_endpoint_validation()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.203Z",
    "modified": "2025-11-22T03:49:51.342Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "91fde69d-2d77-473d-9410-0976bd851b0f",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC002-vehicle deletion or archival with trip validation",
    "description": "Test the /api/admin/vehicles/{vehicleId} DELETE endpoint to verify vehicle deletion or archival behavior when the vehicle has associated trips, including validation of vehicle ID and handling of conflicts.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nVEHICLES_URL = f\"{BASE_URL}/api/admin/vehicles\"\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_vehicle_deletion_or_archival_with_trip_validation():\n    session = requests.Session()\n    try:\n        # Authenticate and get token\n        login_payload = {\n            \"email\": USERNAME,\n            \"password\": PASSWORD\n        }\n        login_resp = session.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.status_code} {login_resp.text}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token, \"No token returned in login response\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Test cases:\n        # 1. DELETE with invalid vehicle ID (not UUID)\n        invalid_id = \"invalid-uuid-123\"\n        resp_invalid = session.delete(f\"{VEHICLES_URL}/{invalid_id}\", headers=headers, timeout=TIMEOUT)\n        assert resp_invalid.status_code == 400, f\"Expected 400 for invalid vehicle ID, got {resp_invalid.status_code}\"\n\n        # 2. DELETE with non-existent but valid UUID vehicle ID - accept 200, 400, 404 or 409\n        non_existent_id = str(uuid.uuid4())\n        resp_nonexistent = session.delete(f\"{VEHICLES_URL}/{non_existent_id}\", headers=headers, timeout=TIMEOUT)\n        assert resp_nonexistent.status_code in (200, 409, 400, 404), \\\n            f\"Unexpected status for non-existent vehicle ID: {resp_nonexistent.status_code}\"\n\n        if resp_nonexistent.status_code == 200:\n            data = resp_nonexistent.json()\n            assert \"success\" in data and isinstance(data[\"success\"], bool)\n            assert \"archived\" in data and isinstance(data[\"archived\"], bool)\n            assert \"tripsCount\" in data and isinstance(data[\"tripsCount\"], int)\n\n    finally:\n        session.close()\n\n\ntest_vehicle_deletion_or_archival_with_trip_validation()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.212Z",
    "modified": "2025-11-22T03:50:30.538Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "d398e9e3-e066-40de-bd9e-b97a871aa229",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC003-generate optimized route stops",
    "description": "Test the /api/admin/generate-stops POST endpoint to ensure optimized route stops are generated successfully for a given route_id and handle failure scenarios.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\ndef test_generate_optimized_route_stops():\n    auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # We need a valid route_id. No direct info on route creation endpoint given.\n    # We'll try to create a dummy route for testing or skip if not available.\n    # Given no route creation API provided, we will simulate failure with invalid UUID first,\n    # then try success case with a dummy valid UUID format.\n\n    import uuid\n\n    valid_route_id = str(uuid.uuid4())  # Generated UUID as dummy route_id for test\n    invalid_route_id = \"invalid-uuid-format\"\n\n    # Helper function to call generate stops endpoint\n    def call_generate_stops(route_id):\n        url = f\"{BASE_URL}/api/admin/generate-stops\"\n        payload = {\"route_id\": route_id}\n        try:\n            response = requests.post(url, auth=auth, headers=headers, json=payload, timeout=TIMEOUT)\n            return response\n        except requests.RequestException as e:\n            raise AssertionError(f\"Request failed: {e}\")\n\n    # Test success scenario (assuming backend accepts any UUID and returns 200)\n    response_success = call_generate_stops(valid_route_id)\n    try:\n        assert response_success.status_code == 200, f\"Expected 200 OK but got {response_success.status_code} with body {response_success.text}\"\n    except AssertionError as e:\n        # It's possible backend requires existing route id.\n        # If 500 or other error received, fail test as generation should succeed for valid route_id\n        raise e\n\n    # Test failure scenario - invalid route_id format or server error handling\n    response_failure = call_generate_stops(invalid_route_id)\n    # The PRD specifies 500 for failure - we accept 4xx or 500 but not 200\n    try:\n        assert response_failure.status_code != 200, (\n            f\"Expected failure status but got 200 OK for invalid route_id, response body: {response_failure.text}\"\n        )\n    except AssertionError as e:\n        raise e\n\ntest_generate_optimized_route_stops()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.218Z",
    "modified": "2025-11-22T03:48:50.999Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "24a8def2-6dcb-4165-a735-729359c593b8",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC004-create new operator user",
    "description": "Test the /api/admin/create-operator POST endpoint for creating a new operator user with valid email and company_id, including validation of input data and error handling.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nCREATE_OPERATOR_ENDPOINT = \"/api/admin/create-operator\"\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_create_new_operator_user():\n    auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    test_email = f\"test_operator_{uuid.uuid4().hex}@example.com\"\n    test_company_id = str(uuid.uuid4())\n\n    payload = {\n        \"email\": test_email,\n        \"company_id\": test_company_id\n    }\n\n    try:\n        response = requests.post(\n            f\"{BASE_URL}{CREATE_OPERATOR_ENDPOINT}\",\n            json=payload,\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 201, f\"Expected 201 Created, got {response.status_code}: {response.text}\"\n\n        # Test invalid data: missing email\n        invalid_payload = {\"company_id\": test_company_id}\n        invalid_resp = requests.post(\n            f\"{BASE_URL}{CREATE_OPERATOR_ENDPOINT}\",\n            json=invalid_payload,\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert invalid_resp.status_code == 400, f\"Expected 400 for missing email, got {invalid_resp.status_code}\"\n\n        # Test invalid data: invalid email format\n        invalid_payload = {\"email\": \"invalidemail\", \"company_id\": test_company_id}\n        invalid_resp2 = requests.post(\n            f\"{BASE_URL}{CREATE_OPERATOR_ENDPOINT}\",\n            json=invalid_payload,\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert invalid_resp2.status_code == 400 or invalid_resp2.status_code == 422, \\\n            f\"Expected 400 or 422 for invalid email format, got {invalid_resp2.status_code}\"\n\n    except Exception as e:\n        assert False, f\"Test failed with exception: {e}\"\n\ntest_create_new_operator_user()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 44, in test_create_new_operator_user\nAssertionError: Expected 400 for missing email, got 201\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 61, in <module>\n  File \"<string>\", line 59, in test_create_new_operator_user\nAssertionError: Test failed with exception: Expected 400 for missing email, got 201\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.224Z",
    "modified": "2025-11-22T03:50:24.129Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "1bf8e063-6372-4b27-a97e-b8426e905b88",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC005-manual cost entry creation and retrieval",
    "description": "Test the /api/costs/manual POST endpoint for creating manual cost entries with valid data and the GET endpoint for retrieving costs with various filters, including validation and authorization.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_EMAIL = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\nTIMEOUT = 30\n\n\ndef get_auth_token(email, password):\n    login_payload = {\"email\": email, \"password\": password}\n    headers = {\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"}\n    response = requests.post(f\"{BASE_URL}/api/auth/login\", headers=headers, json=login_payload, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Login failed with status {response.status_code}, content: {response.text}\"\n    data = response.json()\n    token = data.get('token')\n    assert token, \"No token found in login response\"\n    return token\n\n\ndef test_manual_cost_entry_creation_and_retrieval():\n    # Obtain bearer token via login\n    token = get_auth_token(AUTH_EMAIL, AUTH_PASSWORD)\n\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    test_company_id = \"11111111-1111-1111-1111-111111111111\"\n    test_category_id = \"22222222-2222-2222-2222-222222222222\"\n\n    manual_cost_payload = {\n        \"company_id\": test_company_id,\n        \"cost_category_id\": test_category_id,\n        \"date\": datetime.date.today().isoformat(),\n        \"amount\": 123.45,\n        \"notes\": \"Test manual cost entry creation\",\n        \"source\": \"manual\"\n    }\n\n    # Create manual cost entry\n    response = requests.post(\n        f\"{BASE_URL}/api/costs/manual\",\n        headers=headers,\n        json=manual_cost_payload,\n        timeout=TIMEOUT\n    )\n    assert response.status_code == 201, f\"Expected 201 Created, got {response.status_code}, content: {response.text}\"\n\n    # Retrieve cost entries with filters\n    params = {\"company_id\": test_company_id}\n\n    get_resp = requests.get(\n        f\"{BASE_URL}/api/costs/manual\",\n        headers={\"Accept\": \"application/json\", \"Authorization\": f\"Bearer {token}\"},\n        params=params,\n        timeout=TIMEOUT\n    )\n    assert get_resp.status_code == 200, f\"Expected 200 OK, got {get_resp.status_code}, content: {get_resp.text}\"\n    costs_list = get_resp.json()\n    assert isinstance(costs_list, (list, dict)), \"Response should be a list/dict of costs\"\n\n    # With category filter\n    params_with_category = {\"company_id\": test_company_id, \"category_id\": test_category_id}\n    get_resp_cat = requests.get(\n        f\"{BASE_URL}/api/costs/manual\",\n        headers={\"Accept\": \"application/json\", \"Authorization\": f\"Bearer {token}\"},\n        params=params_with_category,\n        timeout=TIMEOUT\n    )\n    assert get_resp_cat.status_code == 200, f\"Expected 200 OK for category filter, got {get_resp_cat.status_code}, content: {get_resp_cat.text}\"\n\n    # With date range filter\n    start_date = (datetime.date.today() - datetime.timedelta(days=7)).isoformat()\n    end_date = datetime.date.today().isoformat()\n    params_with_dates = {\"company_id\": test_company_id, \"start_date\": start_date, \"end_date\": end_date}\n    get_resp_dates = requests.get(\n        f\"{BASE_URL}/api/costs/manual\",\n        headers={\"Accept\": \"application/json\", \"Authorization\": f\"Bearer {token}\"},\n        params=params_with_dates,\n        timeout=TIMEOUT\n    )\n    assert get_resp_dates.status_code == 200, f\"Expected 200 OK for date filter, got {get_resp_dates.status_code}, content: {get_resp_dates.text}\"\n\n    # With pagination\n    params_with_pagination = {\"company_id\": test_company_id, \"limit\": 10, \"offset\": 0}\n    get_resp_pagination = requests.get(\n        f\"{BASE_URL}/api/costs/manual\",\n        headers={\"Accept\": \"application/json\", \"Authorization\": f\"Bearer {token}\"},\n        params=params_with_pagination,\n        timeout=TIMEOUT\n    )\n    assert get_resp_pagination.status_code == 200, f\"Expected 200 OK for pagination, got {get_resp_pagination.status_code}, content: {get_resp_pagination.text}\"\n\n    # Test with wrong credentials (simulate unauthorized)\n    wrong_login_resp = requests.post(\n        f\"{BASE_URL}/api/auth/login\",\n        headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},\n        json={\"email\": \"invaliduser@example.com\", \"password\": \"wrongpass\"},\n        timeout=TIMEOUT\n    )\n    assert wrong_login_resp.status_code == 400 or wrong_login_resp.status_code == 401, f\"Expected 400 or 401 for invalid login, got {wrong_login_resp.status_code}, content: {wrong_login_resp.text}\"\n\n    # If for some reason login succeeds (should not), try to use token and expect 401 or 403 on manual cost POST\n    if wrong_login_resp.status_code == 200:\n        wrong_token = wrong_login_resp.json().get('token', '')\n        headers_wrong = {\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {wrong_token}\"\n        }\n        resp_unauthorized = requests.post(\n            f\"{BASE_URL}/api/costs/manual\",\n            headers=headers_wrong,\n            json=manual_cost_payload,\n            timeout=TIMEOUT\n        )\n        assert resp_unauthorized.status_code == 401 or resp_unauthorized.status_code == 403, f\"Expected 401 or 403 for unauthorized access, got {resp_unauthorized.status_code}\"\n\n\ntest_manual_cost_entry_creation_and_retrieval()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.230Z",
    "modified": "2025-11-22T03:50:09.093Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "5db92227-a24b-4ea6-b87f-92c11e0d3334",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC006-create employee as operator",
    "description": "Test the /api/operator/create-employee POST endpoint for creating an employee with valid data, handling existing employees, invalid data, unauthorized access, and server errors.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nCREATE_EMPLOYEE_URL = f\"{BASE_URL}/api/operator/create-employee\"\nDELETE_USER_URL_TEMPLATE = f\"{BASE_URL}/api/admin/users/{{user_id}}\"\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef login_and_get_token(username, password):\n    payload = {\"email\": username, \"password\": password}\n    try:\n        resp = requests.post(LOGIN_URL, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        token = data.get(\"token\")\n        assert token, \"Login response missing token\"\n        return token\n    except requests.HTTPError as e:\n        raise AssertionError(f\"Login failed: {e}\")\n\ndef create_employee(auth_token, employee_data):\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return requests.post(CREATE_EMPLOYEE_URL, json=employee_data, headers=headers, timeout=TIMEOUT)\n\ndef test_create_employee_as_operator():\n    token = login_and_get_token(USERNAME, PASSWORD)\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Valid employee data\n    employee_data = {\n        \"email\": \"test.employee@example.com\",\n        \"name\": \"Test Employee\",\n        \"phone\": \"+1234567890\",\n        \"role\": \"passenger\"\n    }\n\n    created_user_id = None\n    try:\n        # 1) Test successful creation (201) or existing employee (200)\n        resp = create_employee(token, employee_data)\n        assert resp.status_code in (200, 201), f\"Unexpected status code for create employee: {resp.status_code}\"\n        resp_json = resp.json()\n        if resp.status_code == 201:\n            # Employee created\n            created_user_id = resp_json.get(\"userId\")\n            assert created_user_id, \"Created response missing userId\"\n            assert resp_json.get(\"email\") == employee_data[\"email\"]\n            assert resp_json.get(\"role\") == employee_data.get(\"role\", \"passenger\")\n            assert resp_json.get(\"created\") is True\n            assert \"companyId\" in resp_json and resp_json[\"companyId\"]\n        else:\n            # Employee already exists\n            # Response body schema not strictly specified for 200, so allow any content JSON\n            pass\n\n        # 2) Test invalid data (missing email)\n        invalid_data = {\n            \"name\": \"Invalid User\"\n        }\n        resp_invalid = create_employee(token, invalid_data)\n        assert resp_invalid.status_code == 400, f\"Expected 400 for invalid employee data, got {resp_invalid.status_code}\"\n\n        # 3) Test unauthorized access: no token\n        resp_no_auth = requests.post(CREATE_EMPLOYEE_URL, json=employee_data, timeout=TIMEOUT)\n        assert resp_no_auth.status_code == 401, f\"Expected 401 Unauthorized when no token is provided, got {resp_no_auth.status_code}\"\n\n        # 4) Test invalid token\n        headers_invalid = {\"Authorization\": \"Bearer invalidtoken123\"}\n        resp_invalid_token = requests.post(CREATE_EMPLOYEE_URL, json=employee_data, headers=headers_invalid, timeout=TIMEOUT)\n        # Could be 401 Unauthorized or 403 Forbidden depending on implementation\n        assert resp_invalid_token.status_code in (401, 403), f\"Expected 401/403 for invalid token, got {resp_invalid_token.status_code}\"\n\n        # 5) Test server error simulation is not specified but check 500 is handled gracefully\n        # This requires special conditions on the server, so we skip actual 500 test\n\n    finally:\n        # Cleanup created employee if created\n        if created_user_id:\n            # Delete employee user via admin endpoint if available\n            # The PRD does not list delete user endpoint, so we do nothing here\n            # Alternatively, could issue DELETE if such API existed\n            pass\n\ntest_create_employee_as_operator()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 88, in <module>\n  File \"<string>\", line 45, in test_create_employee_as_operator\nAssertionError: Unexpected status code for create employee: 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.237Z",
    "modified": "2025-11-22T03:49:32.546Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "1253f572-8fbb-439a-bddc-5f03b13c53c4",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC007-optimize route for operator",
    "description": "Test the /api/operator/optimize-route POST endpoint to verify successful route optimization for operators.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_optimize_route_for_operator():\n    url = f\"{BASE_URL}/api/operator/optimize-route\"\n    try:\n        response = requests.post(\n            url,\n            auth=HTTPBasicAuth(USERNAME, PASSWORD),\n            timeout=TIMEOUT,\n        )\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response is not None, \"No response received\"\n    assert response.status_code == 200, f\"Unexpected status code: {response.status_code}\"\n    # Response described as success with no explicit body schema, check for JSON and expected keys if present\n    try:\n        json_data = response.json()\n    except ValueError:\n        json_data = None\n    # If JSON returned, validate type\n    if json_data is not None:\n        assert isinstance(json_data, dict), \"Response JSON is not a dictionary\"\n\ntest_optimize_route_for_operator()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 31, in <module>\n  File \"<string>\", line 21, in test_optimize_route_for_operator\nAssertionError: Unexpected status code: 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.243Z",
    "modified": "2025-11-22T03:50:00.103Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "e8df32c7-514e-49f5-a00b-5cb6ba82ca20",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC008-generate report on demand",
    "description": "Test the /api/reports/run POST endpoint for generating reports on demand in various formats (pdf, excel, csv) with valid report_type and company_id.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nREPORT_RUN_URL = f\"{BASE_URL}/api/reports/run\"\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef get_auth_token():\n    try:\n        response = requests.post(\n            LOGIN_URL,\n            json={\"email\": USERNAME, \"password\": PASSWORD},\n            timeout=TIMEOUT\n        )\n        response.raise_for_status()\n        data = response.json()\n        token = data.get(\"token\")\n        if not token:\n            raise ValueError(\"No auth token returned in login response\")\n        return token\n    except Exception as e:\n        raise RuntimeError(f\"Authentication failed: {e}\")\n\ndef test_generate_report_on_demand():\n    token = get_auth_token()\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    # We need valid report_type and company_id - since not provided,\n    # typically the test must create or obtain these.\n    # Here we assume minimal sample placeholder values:\n    report_type = \"summary\"   # Assuming \"summary\" is a valid report_type\n    company_id = \"00000000-0000-0000-0000-000000000001\"  # Placeholder UUID\n\n    formats = [\"pdf\", \"excel\", \"csv\"]\n\n    for fmt in formats:\n        payload = {\n            \"report_type\": report_type,\n            \"company_id\": company_id,\n            \"format\": fmt\n        }\n        try:\n            response = requests.post(REPORT_RUN_URL, json=payload, headers=headers, timeout=TIMEOUT)\n            response.raise_for_status()\n            # Response code 200 indicates report generated successfully\n            assert response.status_code == 200\n            # Content-Type can vary but typically should reflect the format; we check presence of data\n            assert response.content is not None and len(response.content) > 0\n        except requests.RequestException as e:\n            raise AssertionError(f\"Request failed for format '{fmt}': {e}\")\n        except AssertionError as ae:\n            raise AssertionError(f\"Assertion failed for format '{fmt}': {ae}\")\n\ntest_generate_report_on_demand()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.250Z",
    "modified": "2025-11-22T03:49:44.554Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "4ca3661d-43cf-4f5e-8472-94cb914dd387",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC009-cron job to dispatch scheduled reports",
    "description": "Test the /api/cron/dispatch-reports POST endpoint to verify that scheduled reports are dispatched successfully and handle invalid CRON_SECRET authentication.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nCRON_DISPATCH_ENDPOINT = f\"{BASE_URL}/api/cron/dispatch-reports\"\nTIMEOUT = 30\n\n\ndef test_cron_dispatch_reports():\n    headers_valid = {\n        \"CRON_SECRET\": \"valid_cron_secret_placeholder\"\n    }\n    headers_invalid = {\n        \"CRON_SECRET\": \"invalid_cron_secret\"\n    }\n\n    # Attempt dispatch with valid CRON_SECRET header\n    try:\n        response = requests.post(\n            CRON_DISPATCH_ENDPOINT,\n            headers=headers_valid,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected 200 for valid CRON_SECRET but got {response.status_code}\"\n        # Optionally check response content if specified\n        try:\n            json_data = response.json()\n            assert isinstance(json_data, (dict, list)) or json_data is None\n        except ValueError:\n            pass\n    except requests.RequestException as e:\n        assert False, f\"Request failed with exception: {e}\"\n\n    # Attempt dispatch with invalid CRON_SECRET header to trigger 401\n    try:\n        response = requests.post(\n            CRON_DISPATCH_ENDPOINT,\n            headers=headers_invalid,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 401, f\"Expected 401 for invalid CRON_SECRET but got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed with exception: {e}\"\n\n\ntest_cron_dispatch_reports()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 45, in <module>\n  File \"<string>\", line 40, in test_cron_dispatch_reports\nAssertionError: Expected 401 for invalid CRON_SECRET but got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.256Z",
    "modified": "2025-11-22T03:50:35.138Z"
  },
  {
    "projectId": "61c14f8f-c994-412d-962a-34e7773a40bc",
    "testId": "37337fdb-893f-4713-93ac-8eab1f64b75a",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC010-system health check endpoint",
    "description": "Test the /api/health GET endpoint to ensure it returns timely and accurate system health status with correct response structure.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\ndef test_system_health_check_endpoint():\n    base_url = \"http://localhost:3000\"\n    endpoint = \"/api/health\"\n    url = base_url + endpoint\n    auth = HTTPBasicAuth(\"golffox@admin.com\", \"senha123\")\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, auth=auth, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request to health endpoint failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        json_response = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(json_response, dict), \"Response JSON is not an object\"\n    assert \"status\" in json_response, \"Response JSON missing 'status' field\"\n    assert \"timestamp\" in json_response, \"Response JSON missing 'timestamp' field\"\n    assert isinstance(json_response[\"status\"], str), \"'status' field is not a string\"\n    assert json_response[\"status\"].lower() == \"ok\", f\"Expected status 'ok', got '{json_response['status']}'\"\n    assert isinstance(json_response[\"timestamp\"], str), \"'timestamp' field is not a string\"\n    # Optionally, validate timestamp format (ISO8601)\n    import datetime\n    try:\n        datetime.datetime.fromisoformat(json_response[\"timestamp\"].replace(\"Z\", \"+00:00\"))\n    except ValueError:\n        assert False, \"timestamp field is not a valid ISO 8601 date-time string\"\n\ntest_system_health_check_endpoint()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-22T03:47:55.262Z",
    "modified": "2025-11-22T03:50:14.679Z"
  }
]
