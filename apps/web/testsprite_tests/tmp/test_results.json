[
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "4e5f8e55-1a8a-42b8-964a-0ca1527b39e7",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC001-Login Success for All User Roles",
    "description": "Check that users with valid credentials can successfully authenticate and are redirected to the correct dashboard or mobile app area based on their role (admin, company, transportadora, motorista, passageiro).",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to find a login page or relevant navigation link on the current page or try alternative URL for login.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find an alternative login page or method to access the login form on the site.\n        await page.goto('http://localhost:3000/auth/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Access Denied: Invalid Credentials').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: Users with valid credentials could not authenticate or were not redirected to the correct dashboard or mobile app area based on their role as specified in the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550544482335//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.562Z",
    "modified": "2025-12-12T14:44:57.822Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "1ddacafb-18e6-4ce5-a920-5eed1b083201",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC002-Login Failure with Incorrect Credentials",
    "description": "Verify that login attempts with invalid username or password fail with appropriate error messages without authentication.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is an alternative URL or navigation element to access the login page or try to navigate directly to a common login URL.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other navigation or links on the main page or try alternative common login URLs or paths.\n        await page.goto('http://localhost:3000/home', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to navigate to root URL or other common login URLs or check if any navigation elements exist on the error page.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Login Successful! Welcome')).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError('Test failed: Login attempt with invalid credentials did not produce the expected failure message and user was incorrectly authenticated.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550556049787//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.574Z",
    "modified": "2025-12-12T14:44:57.830Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "cb70c7e9-c011-4fc2-9a89-41d120826a85",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC003-Role-Based Access Control Enforcement",
    "description": "Confirm that protected routes and API endpoints restrict access based on user roles and prevent unauthorized access.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to the login page or a known route to start the login process for role-based access testing.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other accessible route or page that allows login or navigation to start role-based access testing.\n        await page.goto('http://localhost:3000/auth/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other accessible route or page that allows login or navigation to start role-based access testing.\n        await page.goto('http://localhost:3000/login.html', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other accessible route or page that allows login or navigation to start role-based access testing.\n        await page.goto('http://localhost:3000', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Granted to Admin Dashboard').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Protected routes and API endpoints did not restrict access as expected. Unauthorized access was not properly denied or redirected based on user roles.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/176555055748445//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.580Z",
    "modified": "2025-12-12T14:44:57.841Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "c11f8c6d-12dd-4793-9e8a-ed36a84dd545",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC004-Real-time Fleet Tracking Updates",
    "description": "Verify real-time retrieval and display of GPS locations updates for vehicles and routes on admin and transportadora dashboards within 1 second delay.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is an alternative URL or path to access the login page or app home page.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to access the root URL again or check for any other common login or home page URLs such as /home, /dashboard, or /auth.\n        await page.goto('http://localhost:3000/home', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=veiculo Location Update Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Real-time retrieval and display of GPS location updates for vehicles and routes did not occur within 1 second delay as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/176555053335466//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.585Z",
    "modified": "2025-12-12T14:44:57.848Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "a90206b0-44ea-42ed-a6f1-00945e4fcbf5",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC005-CRUD Operations for Company Management",
    "description": "Test creating, reading, updating, and deleting companies, ensuring persistence of data and UI updates.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to the login page or another known URL to access the app's login interface.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find alternative login access or homepage with login form.\n        await page.goto('http://localhost:3000/admin/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to navigate to the base URL http://localhost:3000 and look for any visible links or buttons to access login or companies management.\n        await page.goto('http://localhost:3000', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Company Creation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan for creating, reading, updating, and deleting companies did not complete successfully. The expected confirmation message \"Company Creation Successful\" was not found, indicating failure in company creation or UI update.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550558280137//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.591Z",
    "modified": "2025-12-12T14:44:57.855Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "e2d5b3a5-8291-40f0-842b-40d75d6a7c79",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC006-Operational Alert Trigger and Notification",
    "description": "Verify alerts trigger correctly on route deviations, emergencies, or operational issues and appropriate notifications are sent to intended users.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is an alternative URL or path to access the login page or app interface.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try accessing the root URL again or check for other possible login paths or instructions.\n        await page.goto('http://localhost:3000', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Route deviation alert triggered').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Alerts for route deviations, emergencies, or operational issues did not trigger as expected, or notifications were not sent to intended users as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550545704049//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.596Z",
    "modified": "2025-12-12T14:44:57.862Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "a6809cdf-9482-4b87-a5e7-f734e5f30133",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC007-Mobile App Checklist and Boarding via QR/NFC",
    "description": "Test motorista and passageiro mobile app flows for completing checklists, scanning QR/NFC codes for embarkation, including offline fallback functionality.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to a known login or app entry page by URL or find an alternative navigation element to access the app.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find alternative URL or navigation to access login or app interface.\n        await page.goto('http://localhost:3000/motorista-login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to navigate to the main app page or find any other accessible login page or entry point.\n        await page.goto('http://localhost:3000/app', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Offline Sync Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution failed to verify offline data storage and synchronization after internet disconnection during QR/NFC scan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550545290906//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.602Z",
    "modified": "2025-12-12T14:44:57.869Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "a5d6c927-f937-41fb-9cd6-c30fcefe54d2",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC008-Report Generation and Export",
    "description": "Validate that financial and operational reports generate correct aggregated data and export properly in PDF, Excel, and CSV formats.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is an alternative login or entry URL or try to navigate to a known login page manually.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try alternative URLs or check if login form is accessible from another page or via navigation.\n        await page.goto('http://localhost:3000/auth', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other accessible URL or check if the app is running properly on localhost:3000.\n        await page.goto('http://localhost:3000/home', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Report Generation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The financial and operational reports did not generate correct aggregated data or export properly in PDF, Excel, and CSV formats as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550546071617//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.607Z",
    "modified": "2025-12-12T14:44:57.876Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "fcc4f54a-47d7-4a2e-8856-522b525c3c9d",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC009-Multi-Tenant Data Isolation Validation",
    "description": "Ensure users cannot access or query data belonging to other tenants, verifying row-level security policies and data segregation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is an alternative login or home page URL or verify the app status before proceeding with login.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find a working login page or alternative access point for the app.\n        await page.goto('http://localhost:3000/home', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        await page.goto('http://localhost:3000/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Check if there is any other URL or method to access the login page or app interface, or verify if the app server is running properly.\n        await page.goto('http://localhost:3000/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Granted to Company B Data').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Users should not be able to access or query data belonging to other tenants. Row-level security policies and data segregation must prevent access to Company B data by a user from Company A.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550558143586//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.613Z",
    "modified": "2025-12-12T14:44:57.883Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "d48f9642-f699-4286-a110-b3428c9a53fb",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC010-Performance and Uptime Monitoring",
    "description": "Verify the system maintains above 99.9% uptime and p95 API response times are below 500ms under normal load.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is an alternative URL or endpoint to access the app or verify the app status via other means.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Check if the app is running or if there is an alternative way to access the app or its monitoring tools.\n        await page.goto('http://localhost:3000/api/health', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Check if there is any login page or dashboard accessible to start monitoring or testing.\n        await page.goto('http://localhost:3000/admin/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=System Uptime Below 99.9% - Test Failed').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The system did not maintain the required 99.9% uptime or the p95 API response times were not below 500ms under normal load as specified in the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550546097263//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.619Z",
    "modified": "2025-12-12T14:44:57.890Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "a481943a-90b6-4932-901d-cc05a2672fbb",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC011-Address Autocomplete and Geocoding Validations",
    "description": "Validate that address inputs provide autocomplete suggestions, CEP lookup works correctly, and geocoding returns accurate coordinates.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to a valid login or home page to start the test or find a working URL for the app.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other accessible page or URL to start the test or report the issue.\n        await page.goto('http://localhost:3000/admin', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to access the app using the provided credentials and URLs or report the issue.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Address autocomplete suggestions are visible').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Address inputs did not provide autocomplete suggestions, CEP lookup or geocoding did not work as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/176555054539934//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.625Z",
    "modified": "2025-12-12T14:44:57.896Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "c992a9ac-95a3-43cb-a596-f6ae2a5e8cca",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC012-Security Controls Verification - CSRF, Rate Limiting, Encryption",
    "description": "Confirm implementation of CSRF protections on forms, rate limiting on APIs, and encryption of sensitive data in transit and at rest.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is an alternative URL or endpoint to access the login or main page of the app.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other accessible pages or endpoints that might allow login or form submission for testing.\n        await page.goto('http://localhost:3000/admin/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other accessible login or main page URL or endpoints to proceed with testing.\n        await page.goto('http://localhost:3000/empresa/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=CSRF Token Missing or Invalid').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: CSRF protection is not properly implemented. Form submissions with missing or invalid CSRF tokens were not rejected as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550545351423//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.630Z",
    "modified": "2025-12-12T14:44:57.903Z"
  },
  {
    "projectId": "c958b032-d1b9-4bcc-bed6-61e2b0cc305f",
    "testId": "491b309b-550b-411d-a328-bc3909fae6fa",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC013-UI Components Render and Interaction",
    "description": "Validate that key reusable UI components such as buttons, dialogs, dropdowns, tables, and toasts render correctly and interactions function as expected.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to a login page or another known entry point to access the app UI components.\n        await page.goto('http://localhost:3000/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to find any other accessible pages or entry points on the app to load UI components.\n        await page.goto('http://localhost:3000/admin/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to navigate to the main app page or a known working page to access UI components.\n        await page.goto('http://localhost:3000/app', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=UI Components Rendered Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan to validate key reusable UI components rendering and interactions did not pass. Expected UI components to render correctly and function as expected, but this was not observed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a478f4f8-c0e1-7076-417b-f3a7d65407fc/1765550554261874//tmp/test_task/result.webm",
    "created": "2025-12-12T14:41:38.635Z",
    "modified": "2025-12-12T14:44:57.909Z"
  }
]
