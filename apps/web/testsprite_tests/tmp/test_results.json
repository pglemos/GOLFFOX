[
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "b09ad3ae-a5a7-415c-8c3d-53cba5faa2f8",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC001-user login endpoint validation",
    "description": "Test the /api/auth/login POST endpoint for successful login with valid credentials, handling of invalid credentials, missing data, authentication failure, and CSRF validation failure.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\ndef test_user_login_endpoint_validation():\n    url = BASE_URL + LOGIN_ENDPOINT\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Successful login with valid credentials\n    valid_payload = {\n        \"email\": \"golffox@admin.com\",\n        \"password\": \"senha123\"\n    }\n    response = requests.post(url, json=valid_payload, headers=headers, timeout=TIMEOUT)\n    try:\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code} with {response.text}\"\n        json_data = response.json()\n        assert \"token\" in json_data and isinstance(json_data[\"token\"], str) and json_data[\"token\"], \"Missing or invalid token\"\n        assert \"refreshToken\" in json_data and isinstance(json_data[\"refreshToken\"], str) and json_data[\"refreshToken\"], \"Missing or invalid refreshToken\"\n        assert \"user\" in json_data and isinstance(json_data[\"user\"], dict), \"Missing or invalid user object\"\n        assert \"session\" in json_data and isinstance(json_data[\"session\"], dict), \"Missing or invalid session object\"\n    except Exception as e:\n        raise AssertionError(f\"Valid login test failed: {str(e)}\")\n\n    # Invalid credentials\n    invalid_payload = {\n        \"email\": \"golffox@admin.com\",\n        \"password\": \"wrongpassword\"\n    }\n    response = requests.post(url, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n    assert response.status_code in {400, 401}, f\"Expected 400 or 401 for invalid credentials, got {response.status_code}\"\n\n    # Missing data: missing password\n    missing_password_payload = {\n        \"email\": \"golffox@admin.com\"\n    }\n    response = requests.post(url, json=missing_password_payload, headers=headers, timeout=TIMEOUT)\n    assert response.status_code == 400, f\"Expected 400 for missing password, got {response.status_code}\"\n\n    # Missing data: missing email\n    missing_email_payload = {\n        \"password\": \"senha123\"\n    }\n    response = requests.post(url, json=missing_email_payload, headers=headers, timeout=TIMEOUT)\n    assert response.status_code == 400, f\"Expected 400 for missing email, got {response.status_code}\"\n\n    # Authentication failure (simulate by missing auth - already covered as no auth mechanism specified)\n    # This scenario is actually covered by missing password or email, no Basic Auth used.\n    # So no distinct test needed here.\n\n    # CSRF validation failure (simulate by sending a header to trigger CSRF failure if applicable)\n    # Since the PRD says CSRF tokens required for mutating API calls, but no specific token passed, test 403 scenario\n    csrf_headers = headers.copy()\n    csrf_headers[\"X-CSRF-Token\"] = \"invalid_token\"\n    response = requests.post(url, json=valid_payload, headers=csrf_headers, timeout=TIMEOUT)\n    assert response.status_code in {200, 403}, f\"Expected 200 or 403 for CSRF token test, got {response.status_code}\"\n\n\ntest_user_login_endpoint_validation()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.811Z",
    "modified": "2025-11-25T04:21:32.646Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "9a987f70-5aa2-4954-be11-f37b7b06fe10",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC002-vehicle deletion or archival with trip validation",
    "description": "Test the /api/admin/vehicles/{vehicleId} DELETE endpoint to verify vehicle deletion or archival behavior when the vehicle has associated trips, including validation of vehicle ID and handling of conflicts.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nAUTH = (\"golffox@admin.com\", \"senha123\")\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_vehicle_deletion_or_archival_with_trip_validation():\n    # Authenticate and obtain a token via login\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\n        \"email\": AUTH[0],\n        \"password\": AUTH[1]\n    }\n    login_resp = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n    login_json = login_resp.json()\n    token = login_json.get(\"token\")\n    assert token, \"No token returned from login\"\n    auth_headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # 1. Deletion with invalid vehicleId (should return 400)\n    invalid_vehicle_id = \"invalid-uuid\"\n    invalid_url = f\"{BASE_URL}/api/admin/vehicles/{invalid_vehicle_id}\"\n    resp_invalid = requests.delete(invalid_url, headers=auth_headers, timeout=TIMEOUT)\n    assert resp_invalid.status_code == 400, f\"Expected 400 for invalid vehicleId, got {resp_invalid.status_code}\"\n\n    # 2. Deletion with a non-existing valid UUID vehicleId (should return 400)\n    non_exist_id = str(uuid.uuid4())\n    non_exist_url = f\"{BASE_URL}/api/admin/vehicles/{non_exist_id}\"\n    resp_non_exist = requests.delete(non_exist_url, headers=auth_headers, timeout=TIMEOUT)\n    assert resp_non_exist.status_code == 400, f\"Expected 400 for non-existing vehicleId, got {resp_non_exist.status_code}\"\n\n\ntest_vehicle_deletion_or_archival_with_trip_validation()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.819Z",
    "modified": "2025-11-25T04:22:00.839Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "6f41e791-1ac9-44ef-8203-0950b8d1bbcc",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC003-generate optimized route stops",
    "description": "Test the /api/admin/generate-stops POST endpoint to ensure optimized route stops are generated successfully for a given route_id and handle failure scenarios.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_generate_optimized_route_stops():\n    auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Test success scenario: generate optimized stops with valid route_id\n    url = f\"{BASE_URL}/api/admin/generate-stops\"\n    valid_route_id = \"11111111-1111-1111-1111-111111111111\"  # Example valid UUID\n    payload = {\n        \"route_id\": valid_route_id\n    }\n    response = requests.post(url, json=payload, headers=headers, auth=auth, timeout=TIMEOUT)\n\n    assert response.status_code == 200, f\"Expected status 200 but got {response.status_code}\"\n\n    # Test failure scenario: generate stops with invalid route_id\n    invalid_payload = {\n        \"route_id\": \"00000000-0000-0000-0000-000000000000\"  # Synthetic invalid UUID\n    }\n    response_fail = requests.post(url, json=invalid_payload, headers=headers, auth=auth, timeout=TIMEOUT)\n    # The response should not be 200 for invalid route_id\n    assert response_fail.status_code != 200, \"Expected failure status code for invalid route_id\"\n\ntest_generate_optimized_route_stops()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.826Z",
    "modified": "2025-11-25T04:21:20.426Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "5f92188a-f988-41c0-a336-1540c6255bae",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC004-create new operator user",
    "description": "Test the /api/admin/create-operator POST endpoint for creating a new operator user with valid email and company_id, including validation of input data and error handling.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nENDPOINT = \"/api/admin/create-operator\"\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_create_new_operator_user():\n    auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Prepare valid payload with unique email and a dummy company_id (UUID4)\n    email = f\"operator_{uuid.uuid4().hex[:8]}@example.com\"\n    # For company_id, provide a valid UUID format, simulate a company Id for the test\n    # As no company create endpoint data provided, use a random UUID here.\n    company_id = str(uuid.uuid4())\n\n    payload = {\n        \"email\": email,\n        \"company_id\": company_id\n    }\n\n    # Test success case: create operator with valid data\n    response = requests.post(\n        BASE_URL + ENDPOINT,\n        auth=auth,\n        headers=headers,\n        json=payload,\n        timeout=TIMEOUT\n    )\n\n    assert response.status_code == 201, f\"Expected status code 201 but got {response.status_code}, response: {response.text}\"\n\n    # Additional validation of response content if JSON\n    try:\n        data = response.json()\n    except Exception:\n        data = None\n    \n    assert data is None or isinstance(data, dict), \"Response is not valid JSON object\"\n\n    # Test error case: invalid email\n    invalid_payload = {\n        \"email\": \"invalid-email\",\n        \"company_id\": company_id\n    }\n    error_response = requests.post(\n        BASE_URL + ENDPOINT,\n        auth=auth,\n        headers=headers,\n        json=invalid_payload,\n        timeout=TIMEOUT\n    )\n    assert error_response.status_code == 400, f\"Expected 400 for invalid email but got {error_response.status_code}, response: {error_response.text}\"\n\n    # Test error case: missing company_id (should get 400)\n    missing_company_payload = {\n        \"email\": f\"operator_{uuid.uuid4().hex[:8]}@example.com\"\n    }\n    missing_company_resp = requests.post(\n        BASE_URL + ENDPOINT,\n        auth=auth,\n        headers=headers,\n        json=missing_company_payload,\n        timeout=TIMEOUT\n    )\n    assert missing_company_resp.status_code == 400, f\"Expected 400 for missing company_id but got {missing_company_resp.status_code}, response: {missing_company_resp.text}\"\n\ntest_create_new_operator_user()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.834Z",
    "modified": "2025-11-25T04:20:55.229Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "159681ab-da62-4630-be0e-77dd844cfbab",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC005-manual cost entry creation and retrieval",
    "description": "Test the /api/costs/manual POST endpoint for creating manual cost entries with valid data and the GET endpoint for retrieving costs with various filters, including validation and authorization.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport uuid\nfrom datetime import date, timedelta\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_manual_cost_entry_creation_and_retrieval():\n    auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\",\n    }\n\n    # Step 1: Retrieve company_id and cost_category_id for testing filters\n    # Since no specific companies or category IDs were provided, we create a manual cost entry to obtain valid IDs\n    # Provide some test data for creation\n    today_str = date.today().isoformat()\n    test_company_id = str(uuid.uuid4())\n    test_cost_category_id = str(uuid.uuid4())\n    test_date = today_str\n    test_amount = 123.45\n    test_notes = \"Test manual cost entry\"\n    test_source = \"manual\"\n\n    cost_entry_payload = {\n        \"company_id\": test_company_id,\n        \"cost_category_id\": test_cost_category_id,\n        \"date\": test_date,\n        \"amount\": test_amount,\n        \"notes\": test_notes,\n        \"source\": test_source\n    }\n\n    # POST /api/costs/manual: create manual cost entry\n    create_response = requests.post(\n        f\"{BASE_URL}/api/costs/manual\",\n        json=cost_entry_payload,\n        auth=auth,\n        headers=headers,\n        timeout=TIMEOUT,\n    )\n    assert create_response.status_code == 201, f\"Expected 201 Created but got {create_response.status_code}: {create_response.text}\"\n\n    # Step 2: GET /api/costs/manual with various filters\n    # Prepare query params with required company_id and optional filters\n    # Test filters: company_id only (required), also add category_id, start_date, end_date, limit, offset\n    query_params_list = [\n        {\"company_id\": test_company_id},  # minimal required\n        {\n            \"company_id\": test_company_id,\n            \"category_id\": test_cost_category_id,\n            \"start_date\": (date.today() - timedelta(days=1)).isoformat(),\n            \"end_date\": (date.today() + timedelta(days=1)).isoformat(),\n            \"limit\": 10,\n            \"offset\": 0,\n        },\n        {\n            \"company_id\": test_company_id,\n            \"limit\": 1,\n        },\n        {\n            \"company_id\": test_company_id,\n            \"offset\": 5,\n        },\n    ]\n\n    for params in query_params_list:\n        get_response = requests.get(\n            f\"{BASE_URL}/api/costs/manual\",\n            params=params,\n            auth=auth,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert get_response.status_code == 200, f\"GET request failed with status code {get_response.status_code}: {get_response.text}\"\n        try:\n            costs_data = get_response.json()\n        except Exception:\n            raise AssertionError(\"Response is not valid JSON\")\n\n        assert isinstance(costs_data, (list, dict)), \"Costs response is not a list or dict\"\n\n# No cleanup is required as endpoint likely stores the cost entry\n\ntest_manual_cost_entry_creation_and_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 88, in <module>\n  File \"<string>\", line 78, in test_manual_cost_entry_creation_and_retrieval\nAssertionError: GET request failed with status code 500: {\"error\":\"{\\\"\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.842Z",
    "modified": "2025-11-25T04:21:50.877Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "46f64cc5-8277-40f2-b8bd-72b45215ee3d",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC006-create employee as operator",
    "description": "Test the /api/operator/create-employee POST endpoint for creating an employee with valid data, handling existing employees, invalid data, unauthorized access, and server errors.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_create_employee_as_operator():\n    # Authenticate to get bearer token via login\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\"email\": USERNAME, \"password\": PASSWORD}\n    login_headers = {\"Content-Type\": \"application/json\"}\n    try:\n        login_resp = requests.post(login_url, json=login_payload, headers=login_headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token, \"No token returned in login response\"\n    except Exception as e:\n        raise AssertionError(f\"Authentication failed: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    url = f\"{BASE_URL}/api/operator/create-employee\"\n\n    # Prepare valid employee data\n    new_employee_email = f\"test_employee_{uuid.uuid4().hex[:8]}@example.com\"\n    valid_employee = {\n        \"email\": new_employee_email,\n        \"name\": \"Test Employee\",\n        \"phone\": \"+1234567890\",\n        \"role\": \"passenger\"\n    }\n\n    # 1. Test creating a new employee with valid data (expect 201 Created)\n    created_user_id = None\n    try:\n        resp = requests.post(url, json=valid_employee, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code in (200, 201), f\"Unexpected status code {resp.status_code} for valid employee creation\"\n        resp_data = resp.json()\n        if resp.status_code == 201:\n            # Employee created successfully\n            created_user_id = resp_data.get(\"userId\")\n            assert created_user_id, \"No userId returned on employee creation\"\n            assert resp_data.get(\"created\") is True, \"Expected 'created' field to be True\"\n            assert resp_data.get(\"email\") == valid_employee[\"email\"], \"Returned email mismatch\"\n            assert resp_data.get(\"role\") == valid_employee[\"role\"], \"Returned role mismatch\"\n            assert \"companyId\" in resp_data, \"No companyId returned\"\n        elif resp.status_code == 200:\n            # Employee already exists\n            assert resp_data.get(\"email\") == valid_employee[\"email\"], \"Returned email mismatch on existing employee\"\n    finally:\n        # Cleanup if created user\n        if created_user_id:\n            # Deleting employee is not specified in PRD or available endpoints,\n            # so no delete is performed here - assuming no direct delete endpoint.\n            pass\n\n    # 2. Test creating an employee with existing email (expect 200 Employee already exists)\n    resp_exist = requests.post(url, json=valid_employee, headers=headers, timeout=TIMEOUT)\n    assert resp_exist.status_code == 200, \"Existing employee creation should return 200\"\n    exist_data = resp_exist.json()\n    assert exist_data.get(\"email\") == valid_employee[\"email\"], \"Returned email mismatch on existing employee\"\n\n    # 3. Test creating employee with invalid data (missing email)\n    invalid_data = {\n        \"name\": \"No Email Employee\",\n        \"phone\": \"+1234567891\"\n        # missing \"email\"\n    }\n    resp_invalid = requests.post(url, json=invalid_data, headers=headers, timeout=TIMEOUT)\n    assert resp_invalid.status_code == 400, f\"Invalid data should return 400 but got {resp_invalid.status_code}\"\n\n    # 4. Test unauthorized access (no token)\n    resp_unauth = requests.post(url, json=valid_employee, headers={\"Content-Type\": \"application/json\"}, timeout=TIMEOUT)\n    assert resp_unauth.status_code == 401, f\"Unauthorized request should return 401 but got {resp_unauth.status_code}\"\n\n    # 5. Test internal server error simulation is difficult via public API; skipped.\n    # However, we can test server error by sending malformed JSON (simulate)\n    malformed_payload = '{\"email\": \"badjson@example.com\"'  # missing closing brace\n    try:\n        resp_error = requests.post(url, data=malformed_payload, headers=headers, timeout=TIMEOUT)\n        # Server might respond with 400 or 500 depending on implementation\n        assert resp_error.status_code in (400, 500), \"Malformed JSON should return 400 or 500\"\n    except requests.exceptions.RequestException as e:\n        # Network or parsing error may occur; treat as pass since simulating server error\n        pass\n\n\ntest_create_employee_as_operator()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.852Z",
    "modified": "2025-11-25T04:21:03.123Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "8575a69b-3be5-4f43-a10a-21f8ee345451",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC007-optimize route for operator",
    "description": "Test the /api/operator/optimize-route POST endpoint to verify successful route optimization for operators.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nOPTIMIZE_ROUTE_URL = f\"{BASE_URL}/api/operator/optimize-route\"\nTIMEOUT = 30\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\ndef test_optimize_route_for_operator():\n    # Login to get token for authorization\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n\n    try:\n        login_response = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n        login_data = login_response.json()\n        assert \"token\" in login_data, \"Login response missing token\"\n        token = login_data[\"token\"]\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Login failed: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        optimize_response = requests.post(OPTIMIZE_ROUTE_URL, headers=headers, timeout=TIMEOUT)\n        assert optimize_response.status_code == 200, f\"Optimize route failed with status code {optimize_response.status_code}\"\n        # The spec does not mandate specific response body; checking presence of success message or similar\n        resp_json = optimize_response.json()\n        assert resp_json is not None, \"Optimize route response is empty or not JSON\"\n    except (requests.RequestException, AssertionError) as e:\n        raise AssertionError(f\"Optimize route request failed: {e}\")\n\ntest_optimize_route_for_operator()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.860Z",
    "modified": "2025-11-25T04:21:09.117Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "96b1f40d-8052-42bc-868f-fa5b3a66c647",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC008-generate report on demand",
    "description": "Test the /api/reports/run POST endpoint for generating reports on demand in various formats (pdf, excel, csv) with valid report_type and company_id.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nREPORT_RUN_URL = f\"{BASE_URL}/api/reports/run\"\nTIMEOUT = 30\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\n\ndef test_generate_report_on_demand():\n    # Authenticate and get token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    try:\n        login_response = requests.post(\n            LOGIN_URL,\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_response.status_code == 200, f\"Login failed: {login_response.text}\"\n        login_data = login_response.json()\n        token = login_data.get(\"token\")\n        assert token and isinstance(token, str), \"Token not found in login response\"\n    except Exception as e:\n        raise AssertionError(f\"Authentication request failed: {e}\")\n\n    # We need company_id and report_type for the report generation\n    # Since not provided, make a dynamic assumption:\n    # For this test, let's create a dummy report_type and company_id placeholders.\n    # If no company_id known, we try to infer from login user info, else skip test fail\n    company_id = None\n    user_info = login_data.get(\"user\", {})\n    if isinstance(user_info, dict):\n        # Attempt to get company_id from user info if available\n        company_id = user_info.get(\"company_id\")\n\n    # If company_id not found, cannot proceed\n    assert company_id is not None, \"company_id not found in user info; cannot run report test\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    report_types = [\"fleet_status\", \"cost_summary\", \"driver_performance\"]\n    formats = [\"pdf\", \"excel\", \"csv\"]\n\n    # Run report generation for each format and report_type combination\n    for report_type in report_types:\n        for fmt in formats:\n            payload = {\n                \"report_type\": report_type,\n                \"company_id\": company_id,\n                \"format\": fmt\n            }\n            try:\n                response = requests.post(\n                    REPORT_RUN_URL,\n                    json=payload,\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n                assert response.status_code == 200, (\n                    f\"Report generation failed for type={report_type}, format={fmt}, \"\n                    f\"status_code={response.status_code}, response={response.text}\"\n                )\n                # Optionally check content-type for different formats\n                content_type = response.headers.get(\"Content-Type\", \"\")\n                if fmt == \"pdf\":\n                    assert \"pdf\" in content_type.lower(), f\"Expected PDF content type, got: {content_type}\"\n                elif fmt == \"excel\":\n                    assert any(x in content_type.lower() for x in [\"excel\", \"spreadsheet\", \"sheet\"]), f\"Expected Excel content type, got: {content_type}\"\n                elif fmt == \"csv\":\n                    assert \"csv\" in content_type.lower(), f\"Expected CSV content type, got: {content_type}\"\n            except Exception as e:\n                raise AssertionError(f\"Report generation request failed for type={report_type}, format={fmt}: {e}\")\n\n\ntest_generate_report_on_demand()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 84, in <module>\n  File \"<string>\", line 43, in test_generate_report_on_demand\nAssertionError: company_id not found in user info; cannot run report test\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.868Z",
    "modified": "2025-11-25T04:21:46.309Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "86da6ad9-abab-44ba-8130-24e4c0a2daf7",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC009-cron job to dispatch scheduled reports",
    "description": "Test the /api/cron/dispatch-reports POST endpoint to verify that scheduled reports are dispatched successfully and handle invalid CRON_SECRET authentication.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nbase_url = \"http://localhost:3000\"\nauth = HTTPBasicAuth(\"golffox@admin.com\", \"senha123\")\ntimeout = 30\n\ndef test_cron_dispatch_reports():\n    url = f\"{base_url}/api/cron/dispatch-reports\"\n\n    # Test case 1: Successful dispatch with valid CRON_SECRET header\n    valid_headers = {\n        \"CRON_SECRET\": \"valid_secret_token\"\n    }\n    try:\n        response = requests.post(url, headers=valid_headers, auth=auth, timeout=timeout)\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        # Optionally check some content or message in response json if available\n    except requests.RequestException as e:\n        assert False, f\"Request failed unexpectedly: {e}\"\n\n    # Test case 2: Authentication failure with invalid CRON_SECRET header\n    invalid_headers = {\n        \"CRON_SECRET\": \"invalid_secret_token\"\n    }\n    try:\n        response = requests.post(url, headers=invalid_headers, auth=auth, timeout=timeout)\n        assert response.status_code == 401, f\"Expected 401 Unauthorized, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed unexpectedly: {e}\"\n\ntest_cron_dispatch_reports()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 32, in <module>\n  File \"<string>\", line 28, in test_cron_dispatch_reports\nAssertionError: Expected 401 Unauthorized, got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.875Z",
    "modified": "2025-11-25T04:21:15.701Z"
  },
  {
    "projectId": "99b5e9b0-78e1-4792-83e7-90cacd365b8f",
    "testId": "8304d56b-a2d9-411d-9469-038652121164",
    "userId": "e4c844a8-80d1-7021-e415-f82e7185a248",
    "title": "TC010-system health check endpoint",
    "description": "Test the /api/health GET endpoint to ensure it returns timely and accurate system health status with correct response structure.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport datetime\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_system_health_check_endpoint():\n    url = f\"{BASE_URL}/api/health\"\n    try:\n        response = requests.get(url, auth=HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD), timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate response structure\n    assert isinstance(data, dict), \"Response JSON is not an object\"\n    assert \"status\" in data, \"Missing 'status' field in response\"\n    assert \"timestamp\" in data, \"Missing 'timestamp' field in response\"\n    assert data[\"status\"] == \"ok\", f\"Expected status 'ok' but got '{data['status']}'\"\n\n    # Validate timestamp field format\n    timestamp = data[\"timestamp\"]\n    try:\n        # This will raise ValueError if format invalid\n        datetime.datetime.fromisoformat(timestamp.replace(\"Z\", \"+00:00\"))\n    except ValueError:\n        assert False, \"timestamp is not a valid ISO 8601 datetime string\"\n\ntest_system_health_check_endpoint()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T04:20:06.883Z",
    "modified": "2025-11-25T04:21:17.391Z"
  }
]
