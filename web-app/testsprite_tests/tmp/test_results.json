[
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "4bc6628c-1d0b-412f-b0fc-99ee44a13fcf",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC001-user login endpoint validation",
    "description": "Test the /api/auth/login POST endpoint for successful login with valid credentials, handling of invalid credentials, missing data, authentication failure, and CSRF validation failure.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_ENDPOINT = \"/api/auth/login\"\nTIMEOUT = 30\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\ndef test_user_login_endpoint_validation():\n    url = BASE_URL + LOGIN_ENDPOINT\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # 1. Test successful login with valid credentials\n    valid_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    try:\n        response = requests.post(url, json=valid_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200, got {response.status_code}\"\n        json_response = response.json()\n        assert \"token\" in json_response and isinstance(json_response[\"token\"], str), \"Missing or invalid token in response\"\n        assert \"refreshToken\" in json_response and isinstance(json_response[\"refreshToken\"], str), \"Missing or invalid refreshToken in response\"\n        assert \"user\" in json_response and isinstance(json_response[\"user\"], dict), \"Missing or invalid user object in response\"\n        assert \"session\" in json_response and isinstance(json_response[\"session\"], dict), \"Missing or invalid session object in response\"\n    except Exception as e:\n        raise AssertionError(f\"Successful login test failed: {e}\")\n\n    # 2. Test login with invalid credentials\n    invalid_payload = {\n        \"email\": USERNAME,\n        \"password\": \"wrongpassword\"\n    }\n    try:\n        response = requests.post(url, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code in (400, 401), f\"Expected 400 or 401 for invalid credentials, got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Invalid credentials test failed: {e}\")\n\n    # 3. Test login with missing email\n    missing_email_payload = {\n        \"password\": PASSWORD\n    }\n    try:\n        response = requests.post(url, json=missing_email_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 400, f\"Expected 400 for missing email, got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Missing email test failed: {e}\")\n\n    # 4. Test login with missing password\n    missing_password_payload = {\n        \"email\": USERNAME\n    }\n    try:\n        response = requests.post(url, json=missing_password_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 400, f\"Expected 400 for missing password, got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Missing password test failed: {e}\")\n\n    # 5. Test authentication failure (simulate by invalid credentials)\n    wrong_payload = {\n        \"email\": \"wronguser@example.com\",\n        \"password\": \"wrongpass\"\n    }\n    try:\n        response = requests.post(url, json=wrong_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code in (400, 401), f\"Expected 400 or 401 for wrong credentials, got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"Authentication failure test failed: {e}\")\n\n    # 6. Test CSRF validation failure (simulate by omitting any CSRF token if required)\n    # Since no specific CSRF token header or data was described, simulate by sending request without auth or malformed headers\n    # We attempt without payload to trigger CSRF or similar rejection\n    try:\n        response = requests.post(url, headers=headers, timeout=TIMEOUT)\n        # API may respond 400 or 403 depending on CSRF or payload validation\n        assert response.status_code == 400 or response.status_code == 403, f\"Expected 400 or 403 for CSRF validation failure or missing payload, got {response.status_code}\"\n    except Exception as e:\n        raise AssertionError(f\"CSRF validation failure test failed: {e}\")\n\n\ntest_user_login_endpoint_validation()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.888Z",
    "modified": "2025-11-11T22:38:35.325Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "1ea18797-4cce-46e8-a875-1dc100a67ab8",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC002-vehicle deletion or archival with trip validation",
    "description": "Test the /api/admin/vehicles/{vehicleId} DELETE endpoint to verify vehicle deletion or archival behavior when the vehicle has associated trips, including validation of vehicle ID and handling of conflicts.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/auth/login\"\nVEHICLE_ENDPOINT = f\"{BASE_URL}/api/admin/vehicles\"\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\nTIMEOUT = 30\n\ndef test_vehicle_deletion_or_archival_with_trip_validation():\n    session = requests.Session()\n    \n    # Authenticate and get token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    login_resp = session.post(LOGIN_ENDPOINT, json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n    login_data = login_resp.json()\n    token = login_data.get(\"token\")\n    assert token and isinstance(token, str), \"Token missing or invalid in login response\"\n    \n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    \n    # Helper function to create a test vehicle\n    def create_test_vehicle():\n        # For vehicle creation, there is no direct endpoint in PRD, so using POST /api/admin/vehicles assumed\n        create_url = f\"{BASE_URL}/api/admin/vehicles\"\n        # Minimal valid payload - assuming at least 'plate' and 'model' needed, using dummy\n        payload = {\n            \"plate\": f\"TEST-{uuid.uuid4().hex[:6].upper()}\",\n            \"model\": \"TestModel 2025\",\n            \"brand\": \"TestBrand\",\n            \"year\": 2025,\n            \"capacity\": 40\n        }\n        resp = session.post(create_url, json=payload, headers=headers, timeout=TIMEOUT)\n        if resp.status_code != 201:\n            raise Exception(f\"Failed to create test vehicle: {resp.status_code} {resp.text}\")\n        return resp.json().get(\"id\") or resp.json().get(\"vehicleId\")\n    \n    # Helper function to delete a vehicle by ID without validation, for cleanup\n    def delete_vehicle(vehicle_id):\n        del_url = f\"{VEHICLE_ENDPOINT}/{vehicle_id}\"\n        session.delete(del_url, headers=headers, timeout=TIMEOUT)\n    \n    vehicle_id = None\n    \n    try:\n        # Step 1: Create a vehicle to test deletion\n        vehicle_id = create_test_vehicle()\n        assert vehicle_id is not None, \"Vehicle ID not returned after creation\"\n        \n        delete_url = f\"{VEHICLE_ENDPOINT}/{vehicle_id}\"\n        \n        # Step 2: Attempt to delete vehicle - expect success with no trips\n        del_resp = session.delete(delete_url, headers=headers, timeout=TIMEOUT)\n        assert del_resp.status_code == 200, f\"Failed to delete vehicle, status code {del_resp.status_code}\"\n        del_data = del_resp.json()\n        assert isinstance(del_data.get(\"success\"), bool), \"Missing success flag in delete response\"\n        assert \"archived\" in del_data, \"Missing archived flag in delete response\"\n        assert isinstance(del_data.get(\"tripsCount\"), int), \"Missing tripsCount in delete response\"\n        # vehicle had no trips, so archived likely False and success True\n        assert del_data[\"success\"] is True\n        \n        # Step 3: Validate invalid vehicle ID returns 400\n        invalid_vehicle_id = \"invalid-uuid-string\"\n        invalid_url = f\"{VEHICLE_ENDPOINT}/{invalid_vehicle_id}\"\n        resp_invalid = session.delete(invalid_url, headers=headers, timeout=TIMEOUT)\n        assert resp_invalid.status_code == 400, f\"Expected 400 for invalid vehicleId, got {resp_invalid.status_code}\"\n        \n        # Step 4: Test conflict scenario with a vehicle that has trips\n        # For that, create another vehicle then simulate trips association or reuse if API supports\n        # Since PRD does not define trips creation, try to reuse same vehicle and forcibly simulate\n        \n        # Create vehicle for conflict test\n        conflict_vehicle_id = create_test_vehicle()\n        assert conflict_vehicle_id is not None\n        \n        # Assuming there's an API or method to associate trips, but none provided in PRD.\n        # We simulate conflict scenario by calling DELETE and expect either archived=True if trips exist or 409 if vehicle in use\n        \n        conflict_url = f\"{VEHICLE_ENDPOINT}/{conflict_vehicle_id}\"\n        \n        # We will mock this by calling DELETE twice:\n        # First delete (no trips) may succeed, so recreate then forcibly call DELETE again for conflict\n        \n        # Delete first time to ensure no trips - should succeed or archive false\n        resp_first_del = session.delete(conflict_url, headers=headers, timeout=TIMEOUT)\n        assert resp_first_del.status_code == 200, \"Expected successful delete/archival on first call\"\n        \n        # Recreate vehicle to simulate vehicle with trips (since no trips creation API)\n        conflict_vehicle_id = create_test_vehicle()\n        conflict_url = f\"{VEHICLE_ENDPOINT}/{conflict_vehicle_id}\"\n        \n        # Simulate vehicle with trips by attempting delete and expecting 409 or archived True\n        # Since API might respond 409 or 200 with archived True and tripsCount > 0 depending on behavior\n        \n        resp_conflict = session.delete(conflict_url, headers=headers, timeout=TIMEOUT)\n        assert resp_conflict.status_code in (200, 409), f\"Expected 200 or 409, got {resp_conflict.status_code}\"\n        if resp_conflict.status_code == 200:\n            data = resp_conflict.json()\n            assert data.get(\"archived\") is True, \"Vehicle with trips should be archived\"\n            assert data.get(\"tripsCount\", 0) > 0, \"Vehicle tripsCount should be greater than 0 on archival\"\n        elif resp_conflict.status_code == 409:\n            # Conflict error response\n            pass\n        \n    finally:\n        # Cleanup - delete vehicles if exist\n        if vehicle_id:\n            try:\n                delete_vehicle(vehicle_id)\n            except Exception:\n                pass\n        if 'conflict_vehicle_id' in locals() and conflict_vehicle_id:\n            try:\n                delete_vehicle(conflict_vehicle_id)\n            except Exception:\n                pass\n\ntest_vehicle_deletion_or_archival_with_trip_validation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 128, in <module>\n  File \"<string>\", line 57, in test_vehicle_deletion_or_archival_with_trip_validation\n  File \"<string>\", line 45, in create_test_vehicle\nException: Failed to create test vehicle: 404 <!DOCTYPE html><html lang=\"pt-BR\"><head><meta charSet=\"utf-8\"/><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/><link rel=\"stylesheet\" href=\"/_next/static/css/app/layout.css?v=1762900674880\" data-precedence=\"next_static/css/app/layout.css\"/><link rel=\"preload\" as=\"script\" fetchPriority=\"low\" href=\"/_next/static/chunks/webpack.js?v=1762900674880\"/><script src=\"/_next/static/chunks/main-app.js?v=1762900674880\" async=\"\"></script><script src=\"/_next/static/chunks/app-pages-internals.js\" async=\"\"></script><script src=\"/_next/static/chunks/app/layout.js\" async=\"\"></script><meta name=\"robots\" content=\"noindex\"/><title>404: This page could not be found.</title><title>GOLF FOX - Gestão de Frotas</title><meta name=\"description\" content=\"Plataforma de gestão de frotas e transporte\"/><script src=\"/_next/static/chunks/polyfills.js\" noModule=\"\"></script></head><body class=\"__className_5c4a2f\"><div hidden=\"\"><!--$--><!--/$--></div><div style=\"font-family:system-ui,&quot;Segoe UI&quot;,Roboto,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;;height:100vh;text-align:center;display:flex;flex-direction:column;align-items:center;justify-content:center\"><div><style>body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}</style><h1 class=\"next-error-h1\" style=\"display:inline-block;margin:0 20px 0 0;padding:0 23px 0 0;font-size:24px;font-weight:500;vertical-align:top;line-height:49px\">404</h1><div style=\"display:inline-block\"><h2 style=\"font-size:14px;font-weight:400;line-height:49px;margin:0\">This page could not be found.</h2></div></div></div><!--$--><!--/$--><div data-rht-toaster=\"\" style=\"position:fixed;z-index:9999;top:16px;left:16px;right:16px;bottom:16px;pointer-events:none\"></div><!--$--><!--/$--><script src=\"/_next/static/chunks/webpack.js?v=1762900674880\" id=\"_R_\" async=\"\"></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,\"5:I[\\\"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"SegmentViewNode\\\"]\\n7:\\\"$Sreact.fragment\\\"\\n16:I[\\\"(app-pages-browser)/./components/error-boundary.tsx\\\",[\\\"app/layout\\\",\\\"static/chunks/app/layout.js\\\"],\\\"ErrorBoundary\\\"]\\n18:I[\\\"(app-pages-browser)/./components/web-vitals-init.tsx\\\",[\\\"app/layout\\\",\\\"static/chunks/app/layout.js\\\"],\\\"WebVitalsInit\\\"]\\n1a:I[\\\"(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"\\\"]\\n1c:I[\\\"(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"\\\"]\\n1f:I[\\\"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\\\",[\\\"app/layout\\\",\\\"static/chunks/app/layout.js\\\"],\\\"Toaster\\\"]\\n21:I[\\\"(app-pages-browser)/./node_modules/@vercel/speed-insights/dist/next/index.mjs\\\",[\\\"app/layout\\\",\\\"static/chunks/app/layout.js\\\"],\\\"SpeedInsights\\\"]\\n34:I[\\\"(app-pages-browser)/./node_modules/next/dist/lib/framework/boundary-components.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"OutletBoundary\\\"]\\n3b:I[\\\"(app-pages-browser)/./node_modules/next/dist/client/components/metadata/async-metadata.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"AsyncMetadataOutlet\\\"]\\n44:I[\\\"(app-pages-browser)/./node_modules/next/dist/lib/framework/boundary-components.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"ViewportBoundary\\\"]\\n4a:I[\\\"(app-pages-browser)/./node_modules/next/dist/lib/framework/boundary-components.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"MetadataBoundary\\\"]\\n4f:\\\"$Sreact.suspense\\\"\\n53:I[\\\"(app-pages-browser)/./node_modules/next/dist/client/components/builtin/global-error.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"\\\"]\\n:HL[\\\"/_next/static/css/app/layout.css?v=1762900674880\\\",\\\"style\\\"]\\n:N1762900674891.4456\\n3:\\\"$EObject.defineProperty(()=\\u003e{ct\"])</script><script>self.__next_f.push([1,\"x.componentMod.preloadStyle(fullHref,ctx.renderOpts.crossOrigin,ctx.nonce)},\\\\\\\"name\\\\\\\",{value:\\\\\\\"\\\\\\\"})\\\"\\n2:{\\\"name\\\":\\\"Preloads\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"stack\\\":[],\\\"props\\\":{\\\"preloadCallbacks\\\":[\\\"$3\\\"]}}\\n4:[]\\n6:[]\\n8:[[\\\"Array.map\\\",\\\"\\\",0,0,0,0,false]]\\nb:I[\\\"(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"\\\"]\\ne:I[\\\"(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\\\",[\\\"app-pages-internals\\\",\\\"static/chunks/app-pages-internals.js\\\"],\\\"\\\"]\\nf:{}\\n10:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\nd:{\\\"children\\\":[\\\"$\\\",\\\"$Le\\\",null,\\\"$f\\\",null,\\\"$10\\\",1]}\\n11:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\nc:{\\\"parallelRouterKey\\\":\\\"children\\\",\\\"error\\\":\\\"$undefined\\\",\\\"errorStyles\\\":\\\"$undefined\\\",\\\"errorScripts\\\":\\\"$undefined\\\",\\\"template\\\":[\\\"$\\\",\\\"$7\\\",null,\\\"$d\\\",null,\\\"$11\\\",0],\\\"templateStyles\\\":\\\"$undefined\\\",\\\"templateScripts\\\":\\\"$undefined\\\",\\\"notFound\\\":\\\"$undefined\\\",\\\"forbidden\\\":\\\"$undefined\\\",\\\"unauthorized\\\":\\\"$undefined\\\",\\\"segmentViewBoundaries\\\":\\\"$Y\\\"}\\n12:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\na:{\\\"name\\\":\\\"RootLayout\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"stack\\\":[],\\\"props\\\":{\\\"children\\\":[\\\"$\\\",\\\"$Lb\\\",null,\\\"$c\\\",null,\\\"$12\\\",1],\\\"params\\\":\\\"$Y\\\"}}\\n13:[[\\\"RootLayout\\\",\\\"webpack-internal:///(rsc)/./app/layout.tsx\\\",27,87,26,1,false]]\\n14:[[\\\"RootLayout\\\",\\\"webpack-internal:///(rsc)/./app/layout.tsx\\\",29,94,26,1,false]]\\n15:[[\\\"RootLayout\\\",\\\"webpack-internal:///(rsc)/./app/layout.tsx\\\",31,98,26,1,false]]\\n17:[[\\\"RootLayout\\\",\\\"webpack-internal:///(rsc)/./app/layout.tsx\\\",33,96,26,1,false]]\\n19:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n1b:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n1d:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n1e:[[\\\"RootLayout\\\",\\\"webpack-internal:///(rsc)/./app/layout.tsx\\\",39,96,26,1,false]]\\n20:[[\\\"RootLayout\\\",\\\"webpack-internal:///(rsc)/./app/layout.tsx\\\",46,96,26,1,false]]\\n22:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n23:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true],[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n24:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true],[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n25:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true],[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n26:[[\\\"F\"])</script><script>self.__next_f.push([1,\"unction.all\\\",\\\"\\\",0,0,0,0,true],[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n28:{\\\"name\\\":\\\"NotFound\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"stack\\\":[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true],[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]],\\\"props\\\":{\\\"params\\\":\\\"$@29\\\",\\\"searchParams\\\":\\\"$@2a\\\"}}\\n2b:{\\\"name\\\":\\\"HTTPAccessErrorFallback\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"owner\\\":\\\"$28\\\",\\\"stack\\\":[],\\\"props\\\":{\\\"status\\\":404,\\\"message\\\":\\\"This page could not be found.\\\"}}\\n2c:[]\\n2d:[]\\n2e:[]\\n2f:[]\\n30:[]\\n31:[]\\n32:[]\\n33:[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true],[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]]\\n37:\\\"$EObject.defineProperty(async function getViewportReady() {\\\\n        await viewport();\\\\n        return undefined;\\\\n    },\\\\\\\"name\\\\\\\",{value:\\\\\\\"getViewportReady\\\\\\\"})\\\"\\n36:{\\\"name\\\":\\\"__next_outlet_boundary__\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"stack\\\":[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true],[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]],\\\"props\\\":{\\\"ready\\\":\\\"$37\\\"}}\\n39:{\\\"name\\\":\\\"StreamingMetadataOutletImpl\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"stack\\\":[[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true],[\\\"Function.all\\\",\\\"\\\",0,0,0,0,true]],\\\"props\\\":{}}\\n3a:[]\\n3d:[]\\n3f:{\\\"name\\\":\\\"NonIndex\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"stack\\\":[],\\\"props\\\":{\\\"pagePath\\\":\\\"/_not-found\\\",\\\"statusCode\\\":404,\\\"isPossibleServerAction\\\":false}}\\n40:[]\\n42:{\\\"name\\\":\\\"ViewportTree\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"stack\\\":[],\\\"props\\\":{}}\\n43:[]\\n46:{\\\"name\\\":\\\"__next_viewport_boundary__\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"owner\\\":\\\"$42\\\",\\\"stack\\\":[],\\\"props\\\":{}}\\n48:{\\\"name\\\":\\\"MetadataTree\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"stack\\\":[],\\\"props\\\":{}}\\n49:[]\\n4c:{\\\"name\\\":\\\"__next_metadata_boundary__\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"owner\\\":\\\"$48\\\",\\\"stack\\\":[],\\\"props\\\":{}}\\n4d:[]\\n4e:[]\\n51:{\\\"name\\\":\\\"MetadataResolver\\\",\\\"key\\\":null,\\\"env\\\":\\\"Server\\\",\\\"owner\\\":\\\"$4c\\\",\\\"stack\\\":[],\\\"props\\\":{}}\\n54:[]\\n29:{}\\n2a:\\n55:[]\\n56:[]\\n57:[]\\n58:[]\\n1:D\\\"$2\\\"\\n1:null\\n9:D\\\"$a\\\"\\n\"])</script><script>self.__next_f.push([1,\"9:[\\\"$\\\",\\\"html\\\",null,{\\\"lang\\\":\\\"pt-BR\\\",\\\"children\\\":[\\\"$\\\",\\\"body\\\",null,{\\\"className\\\":\\\"__className_5c4a2f\\\",\\\"children\\\":[\\\"$\\\",\\\"$L16\\\",null,{\\\"children\\\":[[\\\"$\\\",\\\"$L18\\\",null,{},\\\"$a\\\",\\\"$17\\\",1],[\\\"$\\\",\\\"$L1a\\\",null,{\\\"parallelRouterKey\\\":\\\"children\\\",\\\"error\\\":\\\"$undefined\\\",\\\"errorStyles\\\":\\\"$undefined\\\",\\\"errorScripts\\\":\\\"$undefined\\\",\\\"template\\\":[\\\"$\\\",\\\"$L1c\\\",null,{},null,\\\"$1b\\\",1],\\\"templateStyles\\\":\\\"$undefined\\\",\\\"templateScripts\\\":\\\"$undefined\\\",\\\"notFound\\\":\\\"$undefined\\\",\\\"forbidden\\\":\\\"$undefined\\\",\\\"unauthorized\\\":\\\"$undefined\\\",\\\"segmentViewBoundaries\\\":[\\\"$undefined\\\",\\\"$undefined\\\",\\\"$undefined\\\",[\\\"$\\\",\\\"$L5\\\",null,{\\\"type\\\":\\\"boundary:global-error\\\",\\\"pagePath\\\":\\\"__next_builtin__global-error.js\\\"},null,\\\"$1d\\\",1]]},null,\\\"$19\\\",1],[\\\"$\\\",\\\"$L1f\\\",null,{\\\"position\\\":\\\"top-right\\\"},\\\"$a\\\",\\\"$1e\\\",1],[\\\"$\\\",\\\"$L21\\\",null,{},\\\"$a\\\",\\\"$20\\\",1]]},\\\"$a\\\",\\\"$15\\\",1]},\\\"$a\\\",\\\"$14\\\",1]},\\\"$a\\\",\\\"$13\\\",1]\\n\"])</script><script>self.__next_f.push([1,\"27:D\\\"$28\\\"\\n27:D\\\"$2b\\\"\\n\"])</script><script>self.__next_f.push([1,\"27:[[\\\"$\\\",\\\"title\\\",null,{\\\"children\\\":\\\"404: This page could not be found.\\\"},\\\"$2b\\\",\\\"$2c\\\",1],[\\\"$\\\",\\\"div\\\",null,{\\\"style\\\":{\\\"fontFamily\\\":\\\"system-ui,\\\\\\\"Segoe UI\\\\\\\",Roboto,Helvetica,Arial,sans-serif,\\\\\\\"Apple Color Emoji\\\\\\\",\\\\\\\"Segoe UI Emoji\\\\\\\"\\\",\\\"height\\\":\\\"100vh\\\",\\\"textAlign\\\":\\\"center\\\",\\\"display\\\":\\\"flex\\\",\\\"flexDirection\\\":\\\"column\\\",\\\"alignItems\\\":\\\"center\\\",\\\"justifyContent\\\":\\\"center\\\"},\\\"children\\\":[\\\"$\\\",\\\"div\\\",null,{\\\"children\\\":[[\\\"$\\\",\\\"style\\\",null,{\\\"dangerouslySetInnerHTML\\\":{\\\"__html\\\":\\\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\\\"}},\\\"$2b\\\",\\\"$2f\\\",1],[\\\"$\\\",\\\"h1\\\",null,{\\\"className\\\":\\\"next-error-h1\\\",\\\"style\\\":{\\\"display\\\":\\\"inline-block\\\",\\\"margin\\\":\\\"0 20px 0 0\\\",\\\"padding\\\":\\\"0 23px 0 0\\\",\\\"fontSize\\\":24,\\\"fontWeight\\\":500,\\\"verticalAlign\\\":\\\"top\\\",\\\"lineHeight\\\":\\\"49px\\\"},\\\"children\\\":404},\\\"$2b\\\",\\\"$30\\\",1],[\\\"$\\\",\\\"div\\\",null,{\\\"style\\\":{\\\"display\\\":\\\"inline-block\\\"},\\\"children\\\":[\\\"$\\\",\\\"h2\\\",null,{\\\"style\\\":{\\\"fontSize\\\":14,\\\"fontWeight\\\":400,\\\"lineHeight\\\":\\\"49px\\\",\\\"margin\\\":0},\\\"children\\\":\\\"This page could not be found.\\\"},\\\"$2b\\\",\\\"$32\\\",1]},\\\"$2b\\\",\\\"$31\\\",1]]},\\\"$2b\\\",\\\"$2e\\\",1]},\\\"$2b\\\",\\\"$2d\\\",1]]\\n\"])</script><script>self.__next_f.push([1,\"35:D\\\"$36\\\"\\n38:D\\\"$39\\\"\\n38:[\\\"$\\\",\\\"$L3b\\\",null,{\\\"promise\\\":\\\"$@3c\\\"},\\\"$39\\\",\\\"$3a\\\",1]\\n3e:D\\\"$3f\\\"\\n3e:[\\\"$\\\",\\\"meta\\\",null,{\\\"name\\\":\\\"robots\\\",\\\"content\\\":\\\"noindex\\\"},null,\\\"$40\\\",1]\\n41:D\\\"$42\\\"\\n45:D\\\"$46\\\"\\n41:[[\\\"$\\\",\\\"$L44\\\",null,{\\\"children\\\":\\\"$L45\\\"},\\\"$42\\\",\\\"$43\\\",1],null]\\n47:D\\\"$48\\\"\\n4b:D\\\"$4c\\\"\\n50:D\\\"$51\\\"\\n4b:[\\\"$\\\",\\\"div\\\",null,{\\\"hidden\\\":true,\\\"children\\\":[\\\"$\\\",\\\"$4f\\\",null,{\\\"fallback\\\":null,\\\"children\\\":\\\"$L50\\\"},\\\"$4c\\\",\\\"$4e\\\",1]},\\\"$4c\\\",\\\"$4d\\\",1]\\n47:[\\\"$\\\",\\\"$L4a\\\",null,{\\\"children\\\":\\\"$4b\\\"},\\\"$48\\\",\\\"$49\\\",1]\\n52:[]\\n\"])</script><script>self.__next_f.push([1,\"0:{\\\"P\\\":\\\"$1\\\",\\\"b\\\":\\\"development\\\",\\\"p\\\":\\\"\\\",\\\"c\\\":[\\\"\\\",\\\"api\\\",\\\"admin\\\",\\\"vehicles\\\"],\\\"i\\\":false,\\\"f\\\":[[[\\\"\\\",{\\\"children\\\":[\\\"/_not-found\\\",{\\\"children\\\":[\\\"__PAGE__\\\",{}]}]},\\\"$undefined\\\",\\\"$undefined\\\",true],[\\\"\\\",[\\\"$\\\",\\\"$L5\\\",\\\"layout\\\",{\\\"type\\\":\\\"layout\\\",\\\"pagePath\\\":\\\"layout.tsx\\\",\\\"children\\\":[\\\"$\\\",\\\"$7\\\",\\\"c\\\",{\\\"children\\\":[[[\\\"$\\\",\\\"link\\\",\\\"0\\\",{\\\"rel\\\":\\\"stylesheet\\\",\\\"href\\\":\\\"/_next/static/css/app/layout.css?v=1762900674880\\\",\\\"precedence\\\":\\\"next_static/css/app/layout.css\\\",\\\"crossOrigin\\\":\\\"$undefined\\\",\\\"nonce\\\":\\\"$undefined\\\"},null,\\\"$8\\\",0]],\\\"$9\\\"]},null,\\\"$6\\\",1]},null,\\\"$4\\\",0],{\\\"children\\\":[\\\"/_not-found\\\",[\\\"$\\\",\\\"$7\\\",\\\"c\\\",{\\\"children\\\":[null,[\\\"$\\\",\\\"$L1a\\\",null,{\\\"parallelRouterKey\\\":\\\"children\\\",\\\"error\\\":\\\"$undefined\\\",\\\"errorStyles\\\":\\\"$undefined\\\",\\\"errorScripts\\\":\\\"$undefined\\\",\\\"template\\\":[\\\"$\\\",\\\"$L1c\\\",null,{},null,\\\"$24\\\",1],\\\"templateStyles\\\":\\\"$undefined\\\",\\\"templateScripts\\\":\\\"$undefined\\\",\\\"notFound\\\":\\\"$undefined\\\",\\\"forbidden\\\":\\\"$undefined\\\",\\\"unauthorized\\\":\\\"$undefined\\\",\\\"segmentViewBoundaries\\\":[\\\"$undefined\\\",\\\"$undefined\\\",\\\"$undefined\\\",\\\"$undefined\\\"]},null,\\\"$23\\\",1]]},null,\\\"$22\\\",0],{\\\"children\\\":[\\\"__PAGE__\\\",[\\\"$\\\",\\\"$7\\\",\\\"c\\\",{\\\"children\\\":[[\\\"$\\\",\\\"$L5\\\",\\\"c-page\\\",{\\\"type\\\":\\\"page\\\",\\\"pagePath\\\":\\\"__next_builtin__not-found.js\\\",\\\"children\\\":\\\"$27\\\"},null,\\\"$26\\\",1],null,[\\\"$\\\",\\\"$L34\\\",null,{\\\"children\\\":[\\\"$L35\\\",\\\"$38\\\"]},null,\\\"$33\\\",1]]},null,\\\"$25\\\",0],{},null,false]},null,false]},null,false],[\\\"$\\\",\\\"$7\\\",\\\"h\\\",{\\\"children\\\":[\\\"$3e\\\",\\\"$41\\\",\\\"$47\\\"]},null,\\\"$3d\\\",0],false]],\\\"m\\\":\\\"$W52\\\",\\\"G\\\":[\\\"$53\\\",[\\\"$\\\",\\\"$L5\\\",\\\"ge-svn\\\",{\\\"type\\\":\\\"global-error\\\",\\\"pagePath\\\":\\\"__next_builtin__global-error.js\\\",\\\"children\\\":[]},null,\\\"$54\\\",0]],\\\"s\\\":false,\\\"S\\\":false}\\n\"])</script><script>self.__next_f.push([1,\"45:[[\\\"$\\\",\\\"meta\\\",\\\"0\\\",{\\\"charSet\\\":\\\"utf-8\\\"},\\\"$36\\\",\\\"$55\\\",0],[\\\"$\\\",\\\"meta\\\",\\\"1\\\",{\\\"name\\\":\\\"viewport\\\",\\\"content\\\":\\\"width=device-width, initial-scale=1\\\"},\\\"$36\\\",\\\"$56\\\",0]]\\n35:null\\n3c:{\\\"metadata\\\":[[\\\"$\\\",\\\"title\\\",\\\"0\\\",{\\\"children\\\":\\\"GOLF FOX - Gestão de Frotas\\\"},\\\"$39\\\",\\\"$57\\\",0],[\\\"$\\\",\\\"meta\\\",\\\"1\\\",{\\\"name\\\":\\\"description\\\",\\\"content\\\":\\\"Plataforma de gestão de frotas e transporte\\\"},\\\"$39\\\",\\\"$58\\\",0]],\\\"error\\\":null,\\\"digest\\\":\\\"$undefined\\\"}\\n50:\\\"$3c:metadata\\\"\\n\"])</script></body></html>\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.893Z",
    "modified": "2025-11-11T22:38:12.385Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "83ba4d35-00c0-4c20-b146-f582dd095894",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC003-generate optimized route stops",
    "description": "Test the /api/admin/generate-stops POST endpoint to ensure optimized route stops are generated successfully for a given route_id and handle failure scenarios.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\nTIMEOUT = 30\n\n# Set a valid route_id manually here for testing purpose\nVALID_ROUTE_ID = \"00000000-0000-0000-0000-000000000000\"  # Replace with actual existing route_id\n\ndef test_generate_optimized_route_stops():\n    session = requests.Session()\n    auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n\n    url = f\"{BASE_URL}/api/admin/generate-stops\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # 1. Test successful generation of optimized route stops with valid route_id\n    assert VALID_ROUTE_ID != \"00000000-0000-0000-0000-000000000000\", \"Set VALID_ROUTE_ID to an actual existing route UUID before running this test.\"\n\n    payload = {\"route_id\": VALID_ROUTE_ID}\n    response = session.post(url, json=payload, auth=auth, headers=headers, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n\n    # 2. Test failure scenario with invalid route_id (malformed or non-existent)\n    invalid_payloads = [\n        {\"route_id\": \"invalid-uuid\"},\n        {\"route_id\": str(uuid.uuid4())}  # random UUID likely not existing\n    ]\n    for invalid_payload in invalid_payloads:\n        resp_fail = session.post(url, json=invalid_payload, auth=auth, headers=headers, timeout=TIMEOUT)\n        # According to PRD, failure returns 500 status\n        assert resp_fail.status_code == 500, \\\n            f\"Expected 500 on failure but got {resp_fail.status_code} for payload {invalid_payload}\"\n\n    # 3. Test failure scenario with missing route_id field (empty JSON)\n    resp_missing = session.post(url, json={}, auth=auth, headers=headers, timeout=TIMEOUT)\n    # Possibly 400 or 500 error, accept 400 or 500 as failure indicator\n    assert resp_missing.status_code in [400, 500], \\\n        f\"Expected 400 or 500 for missing route_id, got {resp_missing.status_code}\"\n\n\ntest_generate_optimized_route_stops()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 47, in <module>\n  File \"<string>\", line 23, in test_generate_optimized_route_stops\nAssertionError: Set VALID_ROUTE_ID to an actual existing route UUID before running this test.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.899Z",
    "modified": "2025-11-11T22:38:37.717Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "d33fe073-cefa-4dc4-a389-4447d668e321",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC004-create new operator user",
    "description": "Test the /api/admin/create-operator POST endpoint for creating a new operator user with valid email and company_id, including validation of input data and error handling.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\nTIMEOUT = 30\n\n\ndef test_create_new_operator_user():\n    url = f\"{BASE_URL}/api/admin/create-operator\"\n    auth = (AUTH_USERNAME, AUTH_PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # For test, generate a unique email and a dummy company_id (simulate a valid uuid)\n    new_email = f\"test_operator_{uuid.uuid4().hex[:8]}@example.com\"\n    # A valid UUID string. In real tests should be an existing company_id.\n    dummy_company_id = str(uuid.uuid4())\n\n    payload = {\n        \"email\": new_email,\n        \"company_id\": dummy_company_id\n    }\n\n    created_operator_id = None\n    try:\n        # Send POST request to create operator\n        response = requests.post(url, auth=auth, headers=headers, json=payload, timeout=TIMEOUT)\n\n        # Successful creation returns 201\n        if response.status_code == 201:\n            # Confirm response is JSON and contains expected fields\n            try:\n                resp_json = response.json()\n            except Exception:\n                assert False, \"Response is not valid JSON\"\n\n            # The API doc doesn't specify response body on 201, so only check status code here\n            # but we can optionally check email and company_id match request if returned\n            # Since not specified, just assert status code for success.\n            pass\n\n        elif response.status_code == 400:\n            # Invalid data sent, test that error is handled\n            try:\n                resp_json = response.json()\n            except Exception:\n                resp_json = {}\n            assert \"Invalid\" in str(resp_json) or \"invalid\" in str(resp_json) or resp_json == {} or resp_json.get(\"error\") or True\n\n        elif response.status_code == 500:\n            # Internal server error handled gracefully\n            pass\n\n        else:\n            # Unexpected status code\n            assert False, f\"Unexpected status code: {response.status_code} - Content: {response.text}\"\n\n    finally:\n        # Cleanup: If operator created, try to delete it\n        # No delete endpoint specified for operator users in PRD, so skip cleanup\n        # Because we don't have an endpoint to delete operator user,\n        # the test creates one unique operator user each time or relies on environment reset.\n        pass\n\n\ntest_create_new_operator_user()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 69, in <module>\n  File \"<string>\", line 59, in test_create_new_operator_user\nAssertionError: Unexpected status code: 404 - Content: {\"error\":\"Empresa não encontrada com o company_id fornecido\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.905Z",
    "modified": "2025-11-11T22:38:12.380Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "1770f125-801b-47cc-9e9a-132496d301a9",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC005-manual cost entry creation and retrieval",
    "description": "Test the /api/costs/manual POST endpoint for creating manual cost entries with valid data and the GET endpoint for retrieving costs with various filters, including validation and authorization.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\ndef test_manual_cost_entry_creation_and_retrieval():\n    auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Prepare valid manual cost entry data\n    # For required fields: company_id, cost_category_id, date, amount\n    # Since no specific IDs are provided, attempt to infer or create dummy UUIDs\n    import uuid\n    import datetime\n\n    # Normally, these should come from a fixture or a setup step.\n    # Here we generate dummy UUIDs and current date for test purposes.\n    company_id = str(uuid.uuid4())\n    cost_category_id = str(uuid.uuid4())\n    date = datetime.date.today().isoformat()\n    amount = 123.45\n    notes = \"Test manual cost entry\"\n    source = \"manual\"\n\n    cost_entry = {\n        \"company_id\": company_id,\n        \"cost_category_id\": cost_category_id,\n        \"date\": date,\n        \"amount\": amount,\n        \"notes\": notes,\n        \"source\": source\n    }\n\n    # Create manual cost entry (POST /api/costs/manual)\n    try:\n        response_post = requests.post(\n            f\"{BASE_URL}/api/costs/manual\",\n            json=cost_entry,\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n    except requests.RequestException as e:\n        assert False, f\"POST /api/costs/manual request failed: {e}\"\n\n    # Validate creation success\n    assert response_post.status_code == 201, f\"Expected 201 Created but got {response_post.status_code}\"\n    post_response_json = response_post.json()\n    assert post_response_json is not None, \"POST response JSON is None\"\n\n    # Now test retrieval of costs with filters (GET /api/costs/manual)\n    # Test various valid filters including company_id (required), route_id (empty), vehicle_id (empty),\n    # start_date, end_date, category_id, limit, offset\n\n    # Basic required filter: company_id only\n    params_list = [\n        # Required only\n        {\"company_id\": company_id},\n        # Filters with start_date and end_date range including the created cost date\n        {\n            \"company_id\": company_id,\n            \"start_date\": date,\n            \"end_date\": date,\n        },\n        # With category_id filter matching cost_category_id\n        {\n            \"company_id\": company_id,\n            \"category_id\": cost_category_id\n        },\n        # With limit and offset\n        {\n            \"company_id\": company_id,\n            \"limit\": 10,\n            \"offset\": 0\n        }\n    ]\n\n    for params in params_list:\n        try:\n            response_get = requests.get(\n                f\"{BASE_URL}/api/costs/manual\",\n                headers=headers,\n                auth=auth,\n                params=params,\n                timeout=TIMEOUT\n            )\n        except requests.RequestException as e:\n            assert False, f\"GET /api/costs/manual request failed with params {params}: {e}\"\n\n        # Validate success response\n        assert response_get.status_code == 200, f\"Expected 200 OK but got {response_get.status_code} for params {params}\"\n\n        get_response_json = response_get.json()\n        assert isinstance(get_response_json, (list, dict)), f\"GET response is not list or dict for params {params}\"\n\n        # If it's a dict with results inside, validate accordingly; assuming list of costs or dict.\n        # Check that returned costs (if list) contain an entry matching the created cost entry by date and amount\n        # This is not guaranteed but we attempt best-effort.\n\n        # If list, check for an entry with matching company_id and amount\n        costs = get_response_json if isinstance(get_response_json, list) else get_response_json.get(\"costs\", [])\n\n        found_created_cost = False\n        if isinstance(costs, list):\n            for cost in costs:\n                if (\n                    cost.get(\"company_id\") == company_id and\n                    cost.get(\"cost_category_id\") == cost_category_id and\n                    cost.get(\"date\") == date and\n                    float(cost.get(\"amount\", -1)) == amount\n                ):\n                    found_created_cost = True\n                    break\n        # Since the backend might not immediately reflect data or paginate results,\n        # we don't assert found_created_cost but just note it.\n\n    # Test invalid retrieval: Missing required company_id\n    try:\n        response_invalid = requests.get(\n            f\"{BASE_URL}/api/costs/manual\",\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n    except requests.RequestException as e:\n        assert False, f\"GET /api/costs/manual request without company_id failed: {e}\"\n\n    assert response_invalid.status_code == 400, f\"Expected 400 Bad Request when missing company_id, got {response_invalid.status_code}\"\n\ntest_manual_cost_entry_creation_and_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 135, in <module>\n  File \"<string>\", line 52, in test_manual_cost_entry_creation_and_retrieval\nAssertionError: Expected 201 Created but got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.911Z",
    "modified": "2025-11-11T22:38:09.126Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "2c8ddc24-688f-438e-ab75-415132ab6972",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC006-create employee as operator",
    "description": "Test the /api/operator/create-employee POST endpoint for creating an employee with valid data, handling existing employees, invalid data, unauthorized access, and server errors.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_USERNAME = \"golffox@admin.com\"\nAUTH_PASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_create_employee_as_operator():\n    session = requests.Session()\n    session.auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n    session.headers.update({\"Content-Type\": \"application/json\"})\n\n    endpoint = f\"{BASE_URL}/api/operator/create-employee\"\n\n    # Helper function to attempt employee creation\n    def create_employee(payload):\n        try:\n            response = session.post(endpoint, json=payload, timeout=TIMEOUT)\n            return response\n        except requests.RequestException as e:\n            assert False, f\"Request failed: {e}\"\n\n    # Generate unique email for new employee to avoid conflicts\n    unique_email = f\"test.employee.{uuid.uuid4()}@example.com\"\n\n    # 1. Test creating a new employee with valid data (should create with 201)\n    valid_payload = {\n        \"email\": unique_email,\n        \"name\": \"Test Employee\",\n        \"phone\": \"1234567890\",\n        \"role\": \"passenger\"\n    }\n    created_user_id = None\n    try:\n        response = create_employee(valid_payload)\n        assert response.status_code == 201, f\"Expected 201, got {response.status_code}\"\n        json_resp = response.json()\n        assert json_resp.get(\"created\") is True\n        assert json_resp.get(\"email\") == unique_email\n        assert json_resp.get(\"role\") == \"passenger\"\n        assert \"userId\" in json_resp\n        created_user_id = json_resp[\"userId\"]\n        assert isinstance(created_user_id, str) and len(created_user_id) > 0\n\n        # 2. Test creating the same employee again (should return 200 - employee exists)\n        response_duplicate = create_employee(valid_payload)\n        assert response_duplicate.status_code == 200\n        # No specific schema detailed for this, but at least check no error\n        resp_json_dup = response_duplicate.json() if response_duplicate.content else {}\n        # Employee already exists case: check at minimum response status\n        # resp_json_dup may be empty or contain indication of exists\n\n        # 3. Test creating employee with invalid data (missing email)\n        invalid_payload = {\n            \"name\": \"No Email User\",\n            \"phone\": \"0000000000\",\n            \"role\": \"passenger\"\n        }\n        response_invalid = create_employee(invalid_payload)\n        assert response_invalid.status_code == 400\n\n        # 4. Test unauthorized access (no auth)\n        unauthorized_response = requests.post(endpoint, json=valid_payload, timeout=TIMEOUT)\n        assert unauthorized_response.status_code == 401\n\n        # 5. Test server error simulation (not directly triggerable here, but test server error handling)\n        # We try sending invalid JSON to simulate server error or bad request causing 500\n        # Since invalid data already yields 400, to simulate 500 is not feasible without server control.\n\n    finally:\n        # Attempt to delete the created employee if possible - no delete endpoint documented,\n        # so skipping deletion. In real scenario, would add cleanup code here.\n        pass\n\ntest_create_employee_as_operator()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 77, in <module>\n  File \"<string>\", line 38, in test_create_employee_as_operator\nAssertionError: Expected 201, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.919Z",
    "modified": "2025-11-11T22:38:12.352Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "d2b7e0e4-0ebc-4855-8318-4a0557e69b11",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC007-optimize route for operator",
    "description": "Test the /api/operator/optimize-route POST endpoint to verify successful route optimization for operators.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nOPTIMIZE_ROUTE_URL = f\"{BASE_URL}/api/operator/optimize-route\"\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_optimize_route_for_operator():\n    # Authenticate to get token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    try:\n        login_response = requests.post(\n            LOGIN_URL,\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n        login_data = login_response.json()\n        token = login_data.get(\"token\")\n        assert token and isinstance(token, str), \"Token not present or invalid in login response\"\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    # Call optimize-route endpoint with bearer authentication\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    try:\n        optimize_response = requests.post(\n            OPTIMIZE_ROUTE_URL,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert optimize_response.status_code == 200, f\"Optimize route failed with status code {optimize_response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Optimize route request failed: {e}\"\n\ntest_optimize_route_for_operator()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 45, in <module>\n  File \"<string>\", line 41, in test_optimize_route_for_operator\nAssertionError: Optimize route failed with status code 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.925Z",
    "modified": "2025-11-11T22:38:21.146Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "8e6cf74b-b270-49df-82d7-dea719a77a43",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC008-generate report on demand",
    "description": "Test the /api/reports/run POST endpoint for generating reports on demand in various formats (pdf, excel, csv) with valid report_type and company_id.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/auth/login\"\nREPORT_RUN_ENDPOINT = f\"{BASE_URL}/api/reports/run\"\n\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\n\nTIMEOUT = 30\n\ndef test_generate_report_on_demand():\n    # Step 1: Login to obtain auth token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    try:\n        login_resp = requests.post(\n            LOGIN_ENDPOINT,\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"token\")\n        assert token, \"No token found in login response\"\n    except Exception as e:\n        raise AssertionError(f\"Login request failed: {e}\")\n\n    # Prepare headers with Bearer token\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # For the test, define some sample report_type and company_id\n    # Because they are required, but not given, we create a dummy sample\n    # We choose 'summary' as report_type and some UUID as company_id\n\n    # If these need to be dynamic or created, in real scenario we would create a company and report type,\n    # but here assuming static known values for the test.\n\n    sample_company_id = \"00000000-0000-0000-0000-000000000001\"\n    sample_report_type = \"summary\"\n\n    # Test all allowed formats\n    for fmt in [\"pdf\", \"excel\", \"csv\"]:\n        payload = {\n            \"report_type\": sample_report_type,\n            \"company_id\": sample_company_id,\n            \"format\": fmt\n        }\n        try:\n            resp = requests.post(\n                REPORT_RUN_ENDPOINT,\n                json=payload,\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert resp.status_code == 200, f\"Report generation failed for format {fmt} with status {resp.status_code}\"\n            # Optionally check that response content is not empty (report generated)\n            content = resp.content\n            assert content, f\"Empty response content for report format {fmt}\"\n        except Exception as e:\n            raise AssertionError(f\"Report generation request failed for format {fmt}: {e}\")\n\ntest_generate_report_on_demand()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.931Z",
    "modified": "2025-11-11T22:38:21.143Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "ce82add0-da51-437e-bcba-848ae270d19f",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC009-cron job to dispatch scheduled reports",
    "description": "Test the /api/cron/dispatch-reports POST endpoint to verify that scheduled reports are dispatched successfully and handle invalid CRON_SECRET authentication.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nCRON_DISPATCH_URL = f\"{BASE_URL}/api/cron/dispatch-reports\"\nUSERNAME = \"golffox@admin.com\"\nPASSWORD = \"senha123\"\nTIMEOUT = 30\n\ndef test_cron_dispatch_reports():\n    # Authenticate to get a token\n    try:\n        login_response = requests.post(\n            LOGIN_URL,\n            json={\"email\": USERNAME, \"password\": PASSWORD},\n            timeout=TIMEOUT\n        )\n        assert login_response.status_code == 200, \"Login failed\"\n        login_data = login_response.json()\n        token = login_data.get(\"token\")\n        assert token, \"Token not found in login response\"\n    except Exception as e:\n        raise AssertionError(f\"Login request failed: {e}\")\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Test: invalid CRON_SECRET\n    invalid_headers = headers.copy()\n    invalid_headers[\"x-cron-secret\"] = \"invalid_secret\"\n    try:\n        invalid_response = requests.post(\n            CRON_DISPATCH_URL,\n            headers=invalid_headers,\n            timeout=TIMEOUT\n        )\n        assert invalid_response.status_code == 401, (\n            f\"Expected 401 for invalid CRON_SECRET, got {invalid_response.status_code} with body: {invalid_response.text}\"\n        )\n    except Exception as e:\n        raise AssertionError(f\"Invalid secret dispatch request failed: {e}\")\n\n    # Note: Skipping valid CRON_SECRET test because real secret is unknown\n\n\ntest_cron_dispatch_reports()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.937Z",
    "modified": "2025-11-11T22:38:47.965Z"
  },
  {
    "projectId": "978beee3-b5b9-4e16-bdcf-b9c8a6f397d3",
    "testId": "9dadfd87-8d29-41ae-91d4-eaa33896d8b1",
    "userId": "a478f4f8-c0e1-7076-417b-f3a7d65407fc",
    "title": "TC010-system health check endpoint",
    "description": "Test the /api/health GET endpoint to ensure it returns timely and accurate system health status with correct response structure.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport datetime\n\ndef test_system_health_check_endpoint():\n    base_url = \"http://localhost:3000\"\n    endpoint = \"/api/health\"\n    url = base_url + endpoint\n    auth = HTTPBasicAuth(\"golffox@admin.com\", \"senha123\")\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    timeout = 30\n\n    try:\n        response = requests.get(url, auth=auth, headers=headers, timeout=timeout)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate response schema: object with \"status\" as string and \"timestamp\" as datetime string\n    assert isinstance(data, dict), \"Response JSON is not an object\"\n    assert \"status\" in data, \"'status' key missing in response\"\n    assert isinstance(data[\"status\"], str), \"'status' is not a string\"\n    # Optionally validate the expected value of status to be \"ok\"\n    assert data[\"status\"].lower() == \"ok\", f\"Expected status 'ok', got '{data['status']}'\"\n\n    assert \"timestamp\" in data, \"'timestamp' key missing in response\"\n    assert isinstance(data[\"timestamp\"], str), \"'timestamp' is not a string\"\n    # Validate timestamp format (ISO 8601)\n    try:\n        timestamp = datetime.datetime.fromisoformat(data[\"timestamp\"].replace(\"Z\", \"+00:00\"))\n    except ValueError:\n        assert False, f\"Timestamp '{data['timestamp']}' is not valid ISO 8601 format\"\n\ntest_system_health_check_endpoint()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-11T22:37:22.943Z",
    "modified": "2025-11-11T22:38:29.309Z"
  }
]
